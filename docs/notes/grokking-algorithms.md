### 算法图解笔记

<p align="right">Update: 2020-10-28</p>



#### 广度优先算法

广度优先搜索指出是否有从A到B的路径;
如果有，广度优先搜索将找出最短路径;
面临类似于寻找最短路径的问题时，可尝试用图来建立模型，再使用广度优先搜索来解决问题;
有向图的边为箭头，箭头的方向指定了关系的方向；
无向图的边不带箭头，其中的关系是双向的；
队列是先进先出(FIFO);
栈是后进先出(LIFO);
你需要按照加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列；
对于检查过的人，务必不要再去检查，否则可能导致无限循环；



#### 迪克斯特拉算法步骤
1. 找出最便宜的节点，即可在最短时间内前往的节点；
2. 对于该节点的邻居，检查是否有前往他们的更短的路径，如果有，更新其开销；
3. 重复这一过程，知道对图中的每个节点都这样做了；
4. 计算最终路径。

局限性：迪克斯特拉算法假设对处理过的节点，没有前往该节点的最短路径。

这种假设仅在没有负权边时才成立。

#### 动态规划

动态规划可帮助在给定约束条件下找到最优解。
在问题可分解为彼此独立且离散的字问题时，就可使用动态规划来解决。

通用小帖士:
- 每种动态规划解决方案都设计网格；
- 单元格中的值通常就是要优化的值；
- 每个单元格都是一个子问题；

##### 最长公共子串
计算公式
- 如果两个字母不相同，值为0
- 如果两个字母相同，值为左上方单元格的值加1
- 结果为单元格中的最大值，不一定在最后面

##### 最长公共子序列
最长公共子序列: 两个单词中都有的序列包含的字母数
计算公式
- 如果两个字母不同，就选择上方和左方邻居中较大的那个
- 如果两个字母相同，就将当前单元格的值设置为左上方单元格的值加1
