"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5203],{5906:(e,n,a)=>{a.r(n),a.d(n,{data:()=>s});const s={key:"v-acef946c",path:"/iOS/interview/2-atomic.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"iOS/interview/2-atomic.md",git:{updatedTime:1633942617e3,contributors:[{name:"peak",email:"peak@jiemogame.com",commits:1}]}}},5060:(e,n,a)=>{a.r(n),a.d(n,{default:()=>b});var s=a(6252);const r=(0,s.uE)('<h4 id="原子操作" tabindex="-1"><a class="header-anchor" href="#原子操作" aria-hidden="true">#</a> 原子操作</h4><p><code>atomic</code> 与 <code>nonatomicd</code> 的主要区别就是系统自动生成的 <code>getter</code> / <code>setter</code> 方法不一样</p><ul><li><code>atomic</code> 系统自动生成的 <code>getter</code> / <code>setter</code> 方法会进行加锁操作（<strong>自旋锁</strong>）</li><li><code>nonatomic</code>系统自动生成的 <code>getter</code> / <code>setter</code> 方法不会进行加锁操作</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>@synthesize name = _name;\n- (void)setName:(NSString *)name {\n    @synchronized(self) {\n    _name = [name copy];\n    }\n}\n\n- (NSString *)name {\n    @synchronized(self) {\n        return _name;\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上面代码实现了和 <code>atomic</code> 相同的功能，但是底层的工作方式还是有区别的。我们常常用 <code>@synchronized</code> 来加锁，这种锁是<strong>互斥锁</strong>。而 <code>atomic</code> 修饰的属性自带了一把<strong>自旋锁</strong>。</p><p><strong>互斥锁和自旋锁的区别：</strong></p><table><thead><tr><th>锁名</th><th>作用</th></tr></thead><tbody><tr><td>互斥锁</td><td>当某个资源被先进入的线程上了锁以后，其它后面进入的线程会进入<code>休眠状态</code>。<br>当锁释放后，进入休眠状态的线程变为<code>唤醒状态</code>。</td></tr><tr><td>自旋锁</td><td>当某个资源被先进入的线程上了锁以后，其它后进入的线程会开启一个<code>循环</code>，不断检查锁有没有释放，当锁释放后，退出循环开始访问资源，整个过程中后进入的线程一直保持<code>运行状态</code>。</td></tr></tbody></table><h4 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h4><p><code>atomic</code> 只是保证了 <code>getter</code> 和 <code>setter</code> 存取方法的线程安全,并不能保证整个对象是线程安全的,因此在多线程编程时,线程安全还需要开发者自己来处理.</p><p>下面看一个简单的例子：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>#import &quot;ViewController.h&quot;\n\n@interface ViewController ()\n@property (atomic, assign) NSInteger count;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.count = 0;\n    \n    NSThread *threadA = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething) object:nil];\n    [threadA start];\n    \n    NSThread *threadB = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething) object:nil];\n    [threadB start];\n}\n\n- (void)doSomething {\n    for (NSInteger i = 0; i &lt; 10; i++) {\n        [NSThread sleepForTimeInterval:1.0];\n        self.count++;\n        NSLog(@&quot;self.count = %@ %@&quot;, @(self.count), [NSThread currentThread]);\n    }\n}\n\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>为了让异常情况出现的概率提高，加入一句 <code>[NSThread sleepForTimeInterval:1.0];</code>。</p><p>运行上面的代码，会发现打印的结果中，最后一条 <code>self.count</code> 的值往往是小于 20 的，在中间的某些打印日志中，会发现有些数字被重复打印的两次。</p><p>错误原因： 由于 atomic 仅仅能保证读写是线程安全的，而不是保证 <code>读</code> -&gt; <code>+1</code> -&gt; <code>写</code> ，这个整体是线程安全的。</p><p>线程安全的代码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (void)doSomething {\n    for (NSInteger i = 0; i &lt; 10; i++) {\n        [NSThread sleepForTimeInterval:1.0];\n        @synchronized (self) {\n            self.count++;\n        }\n        NSLog(@&quot;self.count = %@ %@&quot;, @(self.count), [NSThread currentThread]);\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><table><thead><tr><th>修饰符</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>nonatomic</td><td>执行效率高，性能好</td><td>不是线程安全的</td></tr><tr><td>atomic</td><td>线程安全，但是仅能保证写操作的线程安全</td><td>大幅降低执行效率</td></tr></tbody></table><h4 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h4>',18),t={href:"http://liuduo.me/2018/02/08/objective-c-atomic/",target:"_blank",rel:"noopener noreferrer"},l=(0,s.Uk)("Objective-C 原子属性"),o={href:"https://segmentfault.com/a/1190000008808143",target:"_blank",rel:"noopener noreferrer"},c=(0,s.Uk)("从@property说起（三）atomic与多线程锁"),i={href:"https://juejin.im/post/5a31dc76f265da430c11d3ab",target:"_blank",rel:"noopener noreferrer"},d=(0,s.Uk)("iOS中atomic和nonatomic区别及内部实现"),p={},b=(0,a(3744).Z)(p,[["render",function(e,n){const a=(0,s.up)("OutboundLink");return(0,s.wg)(),(0,s.iD)(s.HY,null,[r,(0,s._)("ol",null,[(0,s._)("li",null,[(0,s._)("p",null,[(0,s._)("a",t,[l,(0,s.Wm)(a)])])]),(0,s._)("li",null,[(0,s._)("p",null,[(0,s._)("a",o,[c,(0,s.Wm)(a)])])]),(0,s._)("li",null,[(0,s._)("p",null,[(0,s._)("a",i,[d,(0,s.Wm)(a)])])])])],64)}]])},3744:(e,n)=>{n.Z=(e,n)=>{for(const[a,s]of n)e[a]=s;return e}}}]);