"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2656],{6949:(s,e,n)=>{n.r(e),n.d(e,{data:()=>a});const a={key:"v-47be3449",path:"/iOS/open-analysis/Aspects.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"Aspects 源码阅读",slug:"aspects-源码阅读",children:[]}],filePathRelative:"iOS/open-analysis/Aspects.md",git:{updatedTime:1633945792e3,contributors:[{name:"peak",email:"peak@jiemogame.com",commits:2}]}}},2450:(s,e,n)=>{n.r(e),n.d(e,{default:()=>J});var a=n(6252);const r=(0,a.uE)('<h3 id="aspects-源码阅读" tabindex="-1"><a class="header-anchor" href="#aspects-源码阅读" aria-hidden="true">#</a> Aspects 源码阅读</h3><p align="right">Update: 2020-4-15</p><p>SDK 版本 1.4.2</p><h4 id="文件结构" tabindex="-1"><a class="header-anchor" href="#文件结构" aria-hidden="true">#</a> 文件结构</h4><h5 id="aspecttoken" tabindex="-1"><a class="header-anchor" href="#aspecttoken" aria-hidden="true">#</a> AspectToken</h5><p>用于撤回被hook的方法。</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>@protocol AspectToken &lt;NSObject&gt;\n- (BOOL)remove;\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="aspectinfo" tabindex="-1"><a class="header-anchor" href="#aspectinfo" aria-hidden="true">#</a> AspectInfo</h5><p>用作block回调里面的第一个参数。</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>@protocol AspectInfo &lt;NSObject&gt;\n- (id)instance;\n- (NSInvocation *)originalInvocation;\n- (NSArray *)arguments;\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="aspects分类" tabindex="-1"><a class="header-anchor" href="#aspects分类" aria-hidden="true">#</a> Aspects分类</h5><p>跟NSObject新建一个分类， 分别用户hook类方法和实例方法。</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>@interface NSObject (Aspects)\n\n/// hook 类方法\n+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector\n                           withOptions:(AspectOptions)options\n                            usingBlock:(id)block\n                                 error:(NSError **)error;\n\n/// hook 实例方法\n- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector\n                           withOptions:(AspectOptions)options\n                            usingBlock:(id)block\n                                 error:(NSError **)error;\n\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h5 id="aspectidentifier" tabindex="-1"><a class="header-anchor" href="#aspectidentifier" aria-hidden="true">#</a> AspectIdentifier</h5><p>保存单个需要hook的信息。</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>@interface AspectIdentifier : NSObject\n+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;\n- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;\n@property (nonatomic, assign) SEL selector;\n@property (nonatomic, strong) id block;\n@property (nonatomic, strong) NSMethodSignature *blockSignature;\n@property (nonatomic, weak) id object;\n@property (nonatomic, assign) AspectOptions options;\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="aspectscontainer" tabindex="-1"><a class="header-anchor" href="#aspectscontainer" aria-hidden="true">#</a> AspectsContainer</h5><p>容器对象，保存所有的 <code>AspectIdentifier </code> 信息</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>@interface AspectsContainer : NSObject\n- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;\n- (BOOL)removeAspect:(id)aspect;\n- (BOOL)hasAspects;\n@property (atomic, copy) NSArray *beforeAspects;\n@property (atomic, copy) NSArray *insteadAspects;\n@property (atomic, copy) NSArray *afterAspects;\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h5 id="aspecttracker" tabindex="-1"><a class="header-anchor" href="#aspecttracker" aria-hidden="true">#</a> AspectTracker</h5><p>最终被hook的类以及子类的信息。</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>@interface AspectTracker : NSObject\n- (id)initWithTrackedClass:(Class)trackedClass;\n@property (nonatomic, strong) Class trackedClass;\n@property (nonatomic, readonly) NSString *trackedClassName;\n@property (nonatomic, strong) NSMutableSet *selectorNames;\n@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;\n- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;\n- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;\n- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName;\n- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName;\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="hook流程" tabindex="-1"><a class="header-anchor" href="#hook流程" aria-hidden="true">#</a> hook流程</h4><p>入口函数:</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) {\n    NSCParameterAssert(self);\n    NSCParameterAssert(selector);\n    NSCParameterAssert(block);\n\n    __block AspectIdentifier *identifier = nil;\n  \t// 1. 使用自旋锁来执行block，保证线程安全\n    aspect_performLocked(^{\n        // 2. 检查selector是否能被hook\n        if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) {\n            // 3. 获取容器对象\n            AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector); \n           // 4. 生成 AspectIdentifier 对象，保存hook信息\n            identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];\n            if (identifier) {\n                // 5. 添加到容器\n                [aspectContainer addAspect:identifier withOptions:options];\n\n                // 6. 开始方法拦截\n                aspect_prepareClassAndHookSelector(self, selector, error);\n            }\n        }\n    });\n    return identifier;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h5 id="_1-aspect-performlocked-自旋锁执行block" tabindex="-1"><a class="header-anchor" href="#_1-aspect-performlocked-自旋锁执行block" aria-hidden="true">#</a> 1. <code>aspect_performLocked</code> 自旋锁执行block</h5>',26),l=(0,a.Uk)("自旋锁是效率比较高的一种锁，相比@synchronized来说效率高得多。但是也可能出现问题:"),c={href:"https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/",target:"_blank",rel:"noopener noreferrer"},i=(0,a.Uk)("不再安全的 OSSpinLock"),o=(0,a.Uk)(" : 如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。"),t=(0,a.uE)('<h5 id="_2-检查selector是否能被hook" tabindex="-1"><a class="header-anchor" href="#_2-检查selector是否能被hook" aria-hidden="true">#</a> 2. 检查selector是否能被hook</h5><p>这些方法 <code>retain</code>, <code>release</code>, <code>autorelease</code>, <code>forwardInvocation:</code> 不能被hook;</p><p>hook <code>dealloc</code> 方法时只能使用 <code>AspectPositionBefore</code> 这个枚举值;</p><p>未被实现的方法不能hook；</p><p>元类时，一个方法只能在一个类的层级结构里面被hook一次；</p><h5 id="_3-获取容器对象" tabindex="-1"><a class="header-anchor" href="#_3-获取容器对象" aria-hidden="true">#</a> 3. 获取容器对象</h5><p>动态为当前对象关联一个 <code>AspectsContainer</code> 属性， 保存该对象所有需要hook的信息。</p><h5 id="_4-生成-aspectidentifier-对象-保存hook信息" tabindex="-1"><a class="header-anchor" href="#_4-生成-aspectidentifier-对象-保存hook信息" aria-hidden="true">#</a> 4. 生成 AspectIdentifier 对象，保存hook信息</h5><p>保存需要hook的信息，同时为传入的block生成一个签名信息。</p>',9),p=(0,a.Uk)("作者仿照 "),b={href:"http://clang.llvm.org/docs/Block-ABI-Apple.html#high-level",target:"_blank",rel:"noopener noreferrer"},u=(0,a.Uk)("原生block的结构"),d=(0,a.Uk)(" ，声明了一个类似的结构体 "),m=(0,a._)("code",null,"AspectBlockRef",-1),h=(0,a.Uk)(" , 通过如下方法把block转成结构体:"),k=(0,a.uE)('<div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>static NSMethodSignature *aspect_blockMethodSignature(id block, NSError **error) {\n    //// 将block转换为自定义的block形式\n    AspectBlockRef layout = (__bridge void *)block;\n    if (!(layout-&gt;flags &amp; AspectBlockFlagsHasSignature)) {// 比对layout的第8字节到11字节的第三十位 是不是1（1就是有签名）\n        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&#39;t contain a type signature.&quot;, block];\n        AspectError(AspectErrorMissingBlockSignature, description);\n        return nil;\n    }\n    void *desc = layout-&gt;descriptor;\n    desc += 2 * sizeof(unsigned long int); //desc 地址加上16字节\n    if (layout-&gt;flags &amp; AspectBlockFlagsHasCopyDisposeHelpers) {//比对layout的第8字节到11字节的第25位 是不是1（1就是有COPY_DISPOSE）\n        desc += 2 * sizeof(void *); //desc 再加 8 字节，这时候的地址才是真正signature的地址\n    }\n    if (!desc) {\n        NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&#39;t has a type signature.&quot;, block];\n        AspectError(AspectErrorMissingBlockSignature, description);\n        return nil;\n    }\n    // 转化成NSMethodSignature 对象输出签名\n    const char *signature = (*(const char **)desc);\n    //根据类型编码返回真正方法签名\n    return [NSMethodSignature signatureWithObjCTypes:signature];\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div>',1),g=(0,a.Uk)("具体解释参考: ["),f={href:"https://www.cnblogs.com/DafaRan/p/8192069.html",target:"_blank",rel:"noopener noreferrer"},S=(0,a.Uk)("Aspects 源码学习"),v=(0,a.Uk)("]"),_=(0,a.uE)('<h5 id="_5-把需要hook的信息保存进入进入容器-aspectscontainer-中-方便后续使用" tabindex="-1"><a class="header-anchor" href="#_5-把需要hook的信息保存进入进入容器-aspectscontainer-中-方便后续使用" aria-hidden="true">#</a> 5. 把需要hook的信息保存进入进入容器 <code>AspectsContainer</code> 中, 方便后续使用</h5><h5 id="_6-开始拦截方法" tabindex="-1"><a class="header-anchor" href="#_6-开始拦截方法" aria-hidden="true">#</a> 6. 开始拦截方法</h5><p>具体代码实现为:</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {\n    NSCParameterAssert(selector);\n  \t// 1. hook class\n    Class klass = aspect_hookClass(self, error);\n  \t// 2. hook selector\n    Method targetMethod = class_getInstanceMethod(klass, selector);\n    IMP targetMethodIMP = method_getImplementation(targetMethod);\n    if (!aspect_isMsgForwardIMP(targetMethodIMP)) {\n        // Make a method alias for the existing method implementation, it not already copied.\n        const char *typeEncoding = method_getTypeEncoding(targetMethod);\n        SEL aliasSelector = aspect_aliasForSelector(selector);\n        if (![klass instancesRespondToSelector:aliasSelector]) {\n           // 给子类生成一个辅助方法，方法实现指向被hook的方法的实现\n            __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);\n            NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);\n        }\n\t\t\t\t\n      \t// 强制让被hook的方法，走消息转发流程\n        // We use forwardInvocation to hook in.\n        class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);\n        AspectLog(@&quot;Aspects: Installed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector));\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h6 id="_6-1-hook-class" tabindex="-1"><a class="header-anchor" href="#_6-1-hook-class" aria-hidden="true">#</a> 6.1 hook class</h6><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>static Class aspect_hookClass(NSObject *self, NSError **error) {\n    NSCParameterAssert(self);\n\tClass statedClass = self.class; // 类对象\n\tClass baseClass = object_getClass(self); // 获取当前对象的isa指针\n\tNSString *className = NSStringFromClass(baseClass);\n\n    // Already subclassed\n\tif ([className hasSuffix:AspectsSubclassSuffix]) {\n\t\treturn baseClass;\n\n        // We swizzle a class object, not a single object.\n\t}else if (class_isMetaClass(baseClass)) {\n        return aspect_swizzleClassInPlace((Class)self);\n        // Probably a KVO&#39;ed class. Swizzle in place. Also swizzle meta classes in place.\n    }else if (statedClass != baseClass) {\n        return aspect_swizzleClassInPlace(baseClass);\n    }\n\n    // Default case. Create dynamic subclass.\n\tconst char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;\n\tClass subclass = objc_getClass(subclassName);\n\n\tif (subclass == nil) {\n    // 创建子类\n\t\tsubclass = objc_allocateClassPair(baseClass, subclassName, 0);\n\t\tif (subclass == nil) {\n            NSString *errrorDesc = [NSString stringWithFormat:@&quot;objc_allocateClassPair failed to allocate class %s.&quot;, subclassName];\n            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);\n            return nil;\n    }\n\t  // 子类的`forwardInvocation:`方法，指向`__aspects_forwardInvocation:`\n\t\taspect_swizzleForwardInvocation(subclass); \n    // 子类的isa指针指向statedClass\n\t\taspect_hookedGetClass(subclass, statedClass);\n    // 子类的元类的isa指针指向statedClass\n\t\taspect_hookedGetClass(object_getClass(subclass), statedClass);\n    // 注册子类\n\t\tobjc_registerClassPair(subclass);\n\t}\n\t// 把当前对象的isa指针指向子类\n\tobject_setClass(self, subclass);\n\treturn subclass;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p>其中 <code>Class object_getClass(id obj);</code></p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// 均返回isa指针\n// 1. obj 是实例对象，返回类对象\n// 2. obj 是类对象，返回(meta-class)元类\n// 3. obj 是元类，返回根类的元类\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>先判断是否已经被hook，然后判断是否是类对象，之后判断是否被kvc， 最后动态创建了一个子类。</p><p>核心思想是:</p>',10),A=(0,a.Uk)("创建完子类后，替换子类的 "),C=(0,a._)("code",null,"forwardInvocation:",-1),j=(0,a.Uk)("方法， 并且把子类和当前对象关联。这么做的好处是调用当前对象的方法(当前对象的isa指针指向了子类)，如果找不到实现，走自动转发流程的时候，会调用到子类的 "),N=(0,a._)("code",null,"forwardInvocation:",-1),I=(0,a.Uk)(" 方法里面，子类的 "),y=(0,a._)("code",null,"forwardInvocation:",-1),O=(0,a.Uk)(" 实现被指向了自定义的方法，从而实现了 hook 过程。这里的 "),x={href:"https://github.com/chenxi141017/demo/blob/master/iOS/runtime/aspects/aspects/main.m",target:"_blank",rel:"noopener noreferrer"},E=(0,a.Uk)("demo"),w=(0,a.Uk)(" 模拟了 "),T=(0,a._)("code",null,"Aspects",-1),U=(0,a.Uk)(" 的 hook 流程。"),L=(0,a._)("h6",{id:"_6-2-hook-selector",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#_6-2-hook-selector","aria-hidden":"true"},"#"),(0,a.Uk)(" 6.2 hook selector")],-1),P=(0,a._)("p",null,[(0,a.Uk)("先给子类生成一个 "),(0,a._)("code",null,"aliasSelector"),(0,a.Uk)(" 方法，该方法实现指向被hook的方法实现，然后强制让被hook的方法，走消息转发流程。")],-1),M=(0,a.Uk)("其中关于"),F=(0,a._)("code",null,"_objc_msgForward",-1),B=(0,a.Uk)(" 和 "),z=(0,a._)("code",null,"_objc_msgForward_stret",-1),W=(0,a.Uk)(" 知识可以参考: "),R={href:"http://blog.cnbang.net/tech/2855/",target:"_blank",rel:"noopener noreferrer"},q=(0,a.Uk)("JSPatch实现原理详解<二>"),D=(0,a.Uk)(" 和 "),H={href:"http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html",target:"_blank",rel:"noopener noreferrer"},G=(0,a.Uk)("objc_explain_objc_msgSend_stret"),Y=(0,a.Uk)(" 这两篇文章。"),K=(0,a.uE)('<h6 id="_7-消息转发" tabindex="-1"><a class="header-anchor" href="#_7-消息转发" aria-hidden="true">#</a> 7. 消息转发</h6><p>当被hook的方法被外部调用时，会自动走消息转发流程，而消息转发的实现被 <code>Aspects</code> hook住了， 具体代码如下:</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// This is a macro so we get a cleaner stack trace.\n#define aspect_invoke(aspects, info) \\\nfor (AspectIdentifier *aspect in aspects) {\\\n    [aspect invokeWithInfo:info];\\\n    if (aspect.options &amp; AspectOptionAutomaticRemoval) { \\\n        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \\\n    } \\\n}\n\n// This is the swizzled forwardInvocation: method.\nstatic void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) {\n    NSCParameterAssert(self);\n    NSCParameterAssert(invocation);\n    SEL originalSelector = invocation.selector;\n  \t// 获取辅助方法，该方法的实现指向原来被hook的方法\n\t  SEL aliasSelector = aspect_aliasForSelector(invocation.selector);\n    invocation.selector = aliasSelector;\n  \t// 获取实例对象的容器objectContainer\n    AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);\n    // 获取获得类对象容器classContainer\n  \tAspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);\n    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];\n    NSArray *aspectsToRemove = nil;\n\n    // Before hooks.\n    aspect_invoke(classContainer.beforeAspects, info);\n    aspect_invoke(objectContainer.beforeAspects, info);\n\n    // Instead hooks.\n    BOOL respondsToAlias = YES;\n    if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) {\n        aspect_invoke(classContainer.insteadAspects, info);\n        aspect_invoke(objectContainer.insteadAspects, info);\n    }else {\n        Class klass = object_getClass(invocation.target);\n        do {\n            if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) \t\t\t\t\t\t{\n                [invocation invoke];\n                break;\n            }\n        }while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));\n    }\n\n    // After hooks.\n    aspect_invoke(classContainer.afterAspects, info);\n    aspect_invoke(objectContainer.afterAspects, info);\n\n    // If no hooks are installed, call original implementation (usually to throw an exception)\n    if (!respondsToAlias) {\n        invocation.selector = originalSelector;\n        SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName);\n        if ([self respondsToSelector:originalForwardInvocationSEL]) {\n            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation);\n        }else {\n            [self doesNotRecognizeSelector:invocation.selector];\n        }\n    }\n\n    // Remove any hooks that are queued for deregistration.\n    [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];\n}\n#undef aspect_invoke\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br></div></div><p>一. 消息转发前的准备工作：</p><ol><li>获取原始的selector</li><li>获取带有aspects_xxxx前缀的方法</li><li>替换selector</li><li>获取实例对象的容器objectContainer</li><li>获取获得类对象容器classContainer</li><li>初始化AspectInfo，传入self、invocation参数</li></ol><p>二. 分别在 函数调用之前，替换函数，函数调用之后，执行block；</p><p>主要调用 <code>aspect_invoke</code> 宏定义执行hook功能, 该宏定义有2个作用：</p><ol><li>调用 <code>invokeWithInfo:</code> 方法执行block，把被hook方法里面的参数依次拷贝到block里面，然后执行block；</li><li>记录需要移除的 <code>AspectInfo</code> 信息， 方便后续移除</li></ol><p>三. 移除hook的信息。</p>',9),Z={},J=(0,n(3744).Z)(Z,[["render",function(s,e){const n=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[r,(0,a._)("p",null,[l,(0,a._)("a",c,[i,(0,a.Wm)(n)]),o]),t,(0,a._)("p",null,[p,(0,a._)("a",b,[u,(0,a.Wm)(n)]),d,m,h]),k,(0,a._)("p",null,[g,(0,a._)("a",f,[S,(0,a.Wm)(n)]),v]),_,(0,a._)("p",null,[A,C,j,N,I,y,O,(0,a._)("a",x,[E,(0,a.Wm)(n)]),w,T,U]),L,P,(0,a._)("p",null,[M,F,B,z,W,(0,a._)("a",R,[q,(0,a.Wm)(n)]),D,(0,a._)("a",H,[G,(0,a.Wm)(n)]),Y]),K],64)}]])},3744:(s,e)=>{e.Z=(s,e)=>{for(const[n,a]of e)s[n]=a;return s}}}]);