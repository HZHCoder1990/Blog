"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[548],{7797:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-0d2037cc",path:"/typescript/variable.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"变量",slug:"变量",children:[]}],filePathRelative:"typescript/variable.md",git:{updatedTime:1633942617e3,contributors:[{name:"peak",email:"peak@jiemogame.com",commits:1}]}}},9854:(n,e,s)=>{s.r(e),s.d(e,{default:()=>m});var a=s(6252);const r=(0,a.uE)('<h3 id="变量" tabindex="-1"><a class="header-anchor" href="#变量" aria-hidden="true">#</a> 变量</h3><p align="right">2019-1-5</p><p>在<code>JavaScript</code>中，使用<code>let</code>，<code>const</code>，<code>var</code>来声明变量。<code>let</code>和<code>var</code>在某些情况下比较相似，但是使用<code>let</code>可以避免一些常见的陷阱. <code>const</code> 声明的变量无法对其进行重新赋值。</p><p><code>TypeScript</code>作为<code>JavaScript</code>的超集，也支持也上几种变量的声明方式。</p><h4 id="var声明" tabindex="-1"><a class="header-anchor" href="#var声明" aria-hidden="true">#</a> var声明</h4><p>使用<code>var</code>关键字来声明变量。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var a = 10;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>在一个函数内部声明变量。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function f() {\n    var message = &quot;Hello, world!&quot;;\n\n    return message;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在其他函数中方法相同的变量.</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function f() {\n    var a = 10;\n    return function g() {\n        var b = a + 1;\n        return b;\n    }\n}\n\nvar g = f();\ng(); // returns &#39;11&#39;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在上面的例子中函数<code>g</code>捕获了声明在f函数中的变量<code>a</code>， 当<code>g</code>函数被调用的时候，内部的a的值与在f函数中的变量<code>a</code>的值相关联。 尽管<code>g</code>调用的时候函数f已经执行完了，还是能够对变量<code>a</code>进行读写操作。</p><p>如下示例:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function f() {\n    var a = 1;\n\n    a = 2;\n    var b = g();\n    a = 3;\n\n    return b;\n\n    function g() {\n        return a;\n    }\n}\n\nf(); // returns &#39;2&#39;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h5 id="作用域规则" tabindex="-1"><a class="header-anchor" href="#作用域规则" aria-hidden="true">#</a> 作用域规则</h5><p>相对于其他语言，<code>JavaScript</code>中<code>var</code>声明的变量有一些奇怪的作用域规则。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function f(shouldInitialize: boolean) {\n    if (shouldInitialize) {\n        var x = 10;\n    }\n\n    return x;\n}\n\nf(true);  // returns &#39;10&#39;\nf(false); // returns &#39;undefined&#39;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>变量<code>x</code>声明在<code>if</code>语句内，但是我们能够在<code>if</code>语句之外访问它。这是因为<code>var</code>声明的变量可以在它所在的函数，模块，命名空间或全局范围内的任何地方访问。</p><p>这种作用域规则可能会导致多种类型的错误，其中一个问题是<strong>多次声明同一个变量并不抛出错误提示</strong>：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function sumMatrix(matrix: number[][]) {\n    var sum = 0;\n    for (var i = 0; i &lt; matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (var i = 0; i &lt; currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>很容易发现错误， 内部的<code>for</code>循环声明的变量<code>i</code>会覆盖外部的<code>for</code>循环声明的变量<code>i</code>，他们引用了同一个变量。</p><h5 id="变量捕获的模式" tabindex="-1"><a class="header-anchor" href="#变量捕获的模式" aria-hidden="true">#</a> 变量捕获的模式</h5><p>看一下如下的例子：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>for (var i = 0; i &lt; 10; i++) {\n    setTimeout(function() { console.log(i); }, 100 * i); // setTimeout 延时执行函数\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>实际输出结果如下:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>许多<code>JavaScript</code>开发人员都非常熟悉这种行为, 但是对很多新手来书，期待的输出如下:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>产生错误的原因是我们传递给<code>setTimeout</code>函数的参数实际上引用的同一个值. <code>setTimeout</code>函数将会在延迟一段时间之后执行，这时候<code>for</code>循环已经执行完毕，<code>i</code>的值是10，所以每次输出都是10.</p><p>常见的解决办法是： 每次循环都捕获一下变量i:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>for (var i = 0; i &lt; 10; i++) {\n    // capture the current state of &#39;i&#39;\n    // by invoking a function with its current value\n    (function(i) {\n        setTimeout(function() { console.log(i); }, 100 * i);\n    })(i);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="let-声明" tabindex="-1"><a class="header-anchor" href="#let-声明" aria-hidden="true">#</a> let 声明</h4><p>除了关键字之外使用<code>let</code>声明变量跟使用<code>var</code>声明变量的方式没什么不同。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let hello = &quot;Hello!&quot;;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h5 id="块作用域" tabindex="-1"><a class="header-anchor" href="#块作用域" aria-hidden="true">#</a> 块作用域</h5><p>与使用<code>var</code>声明的变量（其范围泄漏到其包含的函数）不同，使用<code>let</code>声明的变量在块作用域之外无法访问。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function f(input: boolean) {\n    let a = 100;\n\n    if (input) {\n        // Still okay to reference &#39;a&#39;\n        let b = a + 1;\n        return b;\n    }\n\n    // Error: &#39;b&#39; doesn&#39;t exist here\n    return b;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>有两个本地变量<code>a</code>和<code>b</code>， <code>a</code>的作用范围限制在了函数<code>f</code>内， <code>b</code>的作用范围限制在了<code>if</code>语句内。</p><p>变量声明在catch语句中有同样的作用域规则。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>try {\n    throw &quot;oh no!&quot;;\n}\ncatch (e) {\n    console.log(&quot;Oh well.&quot;);\n}\n\n// Error: &#39;e&#39; doesn&#39;t exist here\nconsole.log(e);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>变量在声明之前禁止使用:</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>a++; // illegal to use &#39;a&#39; before it&#39;s declared;\nlet a;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h5 id="重复声明" tabindex="-1"><a class="header-anchor" href="#重复声明" aria-hidden="true">#</a> 重复声明</h5><p>使用<code>var</code>可以声明一个变量多次， 使用<code>let</code>禁止声明同一个变量多次。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function f(x) {\n    var x;\n    var x;\n\n    if (true) {\n        var x;\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let x = 10;\nlet x = 20; // error: can&#39;t re-declare &#39;x&#39; in the same scope\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h5 id="变量捕获" tabindex="-1"><a class="header-anchor" href="#变量捕获" aria-hidden="true">#</a> 变量捕获</h5><p>每次在一个作用域范围内运行时，它都会创建一个变量的“环境”。 即使在其范围内的所有内容都已完成执行后，该环境及其捕获的变量也可以存在。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function theCityThatAlwaysSleeps() {\n    let getCity;\n\n    if (true) {\n        let city = &quot;Seattle&quot;;\n        getCity = function() {\n            return city;\n        }\n    }\n\n    return getCity();\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>for (let i = 0; i &lt; 10 ; i++) {\n    setTimeout(function() { console.log(i); }, 100 * i);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="const-声明" tabindex="-1"><a class="header-anchor" href="#const-声明" aria-hidden="true">#</a> const 声明</h4><p>const声明的变量无法对其重新赋值。</p><h4 id="解构" tabindex="-1"><a class="header-anchor" href="#解构" aria-hidden="true">#</a> 解构</h4><p>ECMAScript 2015 的一个新特性之一就是解构。</p><h5 id="数组解构" tabindex="-1"><a class="header-anchor" href="#数组解构" aria-hidden="true">#</a> 数组解构</h5><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // outputs 1\nconsole.log(second); // outputs 2\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>创建了两个新的变量first和name并对他们重新赋值， 这比使用下标赋值更加方便。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>first = input[0];\nsecond = input[1];\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>解构对于已经声明过的变量来说同样适用：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 变量交换\n[first, second] = [second, first];\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>对于数组中剩下的元素可以使用<code>...</code>语法来表示:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\nconsole.log(rest); // outputs [ 2, 3, 4 ]\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以忽略不关心的元素:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n\nlet [, second, , fourth] = [1, 2, 3, 4];\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="object-解构" tabindex="-1"><a class="header-anchor" href="#object-解构" aria-hidden="true">#</a> Object 解构</h5><p>创建变量a、b，使用o.a 和 o.b分别对他们进行赋值：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let o = {\n    a: &quot;foo&quot;,\n    b: 12,\n    c: &quot;bar&quot;\n};\nlet { a, b } = o;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>属性重命名</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let { a: newName1, b: newName2 } = o;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>等价于:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let newName1 = o.a;\nlet newName2 = o.b;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>分号在这里不要是变量类型</strong></p><h4 id="spread-扩展" tabindex="-1"><a class="header-anchor" href="#spread-扩展" aria-hidden="true">#</a> Spread(扩展)</h4><p>跟解构是相反的操作。它能够将数组扩展到另一个数组，或将对象扩展到另一个对象。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5]; // [0, 1, 2, 3, 4, 5]\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',76),l=(0,a._)("strong",null,"扩展Object",-1),i=(0,a.Uk)(": (只能扩展"),c={href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties",target:"_blank",rel:"noopener noreferrer"},p=(0,a.Uk)("自己的可枚举属性"),t=(0,a.Uk)("，无法对函数进行扩展)"),b=(0,a.uE)('<div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let defaults = { food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; };\nlet search = { ...defaults, food: &quot;rich&quot; }; // { food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h4>',2),u={href:"https://www.typescriptlang.org/docs/handbook/variable-declarations.html",target:"_blank",rel:"noopener noreferrer"},d=(0,a.Uk)("variable-declarations"),o={},m=(0,s(3744).Z)(o,[["render",function(n,e){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[r,(0,a._)("p",null,[l,i,(0,a._)("a",c,[p,(0,a.Wm)(s)]),t]),b,(0,a._)("p",null,[(0,a._)("a",u,[d,(0,a.Wm)(s)])])],64)}]])},3744:(n,e)=>{e.Z=(n,e)=>{for(const[s,a]of e)n[s]=a;return n}}}]);