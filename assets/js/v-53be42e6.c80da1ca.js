"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3501],{488:(e,a,i)=>{i.r(a),i.d(a,{data:()=>l});const l={key:"v-53be42e6",path:"/notes/grokking-algorithms.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"算法图解笔记",slug:"算法图解笔记",children:[]}],filePathRelative:"notes/grokking-algorithms.md",git:{updatedTime:1633942617e3,contributors:[{name:"peak",email:"peak@jiemogame.com",commits:1}]}}},6900:(e,a,i)=>{i.r(a),i.d(a,{default:()=>h});const l=(0,i(6252).uE)('<h3 id="算法图解笔记" tabindex="-1"><a class="header-anchor" href="#算法图解笔记" aria-hidden="true">#</a> 算法图解笔记</h3><p align="right">Update: 2020-10-28</p><h4 id="广度优先算法" tabindex="-1"><a class="header-anchor" href="#广度优先算法" aria-hidden="true">#</a> 广度优先算法</h4><p>广度优先搜索指出是否有从A到B的路径; 如果有，广度优先搜索将找出最短路径; 面临类似于寻找最短路径的问题时，可尝试用图来建立模型，再使用广度优先搜索来解决问题; 有向图的边为箭头，箭头的方向指定了关系的方向； 无向图的边不带箭头，其中的关系是双向的； 队列是先进先出(FIFO); 栈是后进先出(LIFO); 你需要按照加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列； 对于检查过的人，务必不要再去检查，否则可能导致无限循环；</p><h4 id="迪克斯特拉算法步骤" tabindex="-1"><a class="header-anchor" href="#迪克斯特拉算法步骤" aria-hidden="true">#</a> 迪克斯特拉算法步骤</h4><ol><li>找出最便宜的节点，即可在最短时间内前往的节点；</li><li>对于该节点的邻居，检查是否有前往他们的更短的路径，如果有，更新其开销；</li><li>重复这一过程，知道对图中的每个节点都这样做了；</li><li>计算最终路径。</li></ol><p>局限性：迪克斯特拉算法假设对处理过的节点，没有前往该节点的最短路径。</p><p>这种假设仅在没有负权边时才成立。</p><h4 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划" aria-hidden="true">#</a> 动态规划</h4><p>动态规划可帮助在给定约束条件下找到最优解。 在问题可分解为彼此独立且离散的字问题时，就可使用动态规划来解决。</p><p>通用小帖士:</p><ul><li>每种动态规划解决方案都设计网格；</li><li>单元格中的值通常就是要优化的值；</li><li>每个单元格都是一个子问题；</li></ul><h5 id="最长公共子串" tabindex="-1"><a class="header-anchor" href="#最长公共子串" aria-hidden="true">#</a> 最长公共子串</h5><p>计算公式</p><ul><li>如果两个字母不相同，值为0</li><li>如果两个字母相同，值为左上方单元格的值加1</li><li>结果为单元格中的最大值，不一定在最后面</li></ul><h5 id="最长公共子序列" tabindex="-1"><a class="header-anchor" href="#最长公共子序列" aria-hidden="true">#</a> 最长公共子序列</h5><p>最长公共子序列: 两个单词中都有的序列包含的字母数 计算公式</p><ul><li>如果两个字母不同，就选择上方和左方邻居中较大的那个</li><li>如果两个字母相同，就将当前单元格的值设置为左上方单元格的值加1</li></ul>',18),r={},h=(0,i(3744).Z)(r,[["render",function(e,a){return l}]])},3744:(e,a)=>{a.Z=(e,a)=>{for(const[i,l]of a)e[i]=l;return e}}}]);