"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2331],{1662:(e,n,a)=>{a.r(n),a.d(n,{data:()=>s});const s={key:"v-0336cf9a",path:"/iOS/interview/1-category-and-extension.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"基本概念",slug:"基本概念",children:[]},{level:3,title:"常见问题",slug:"常见问题",children:[]},{level:3,title:"Category 特性在 iOS 组件化中的应用与管控",slug:"category-特性在-ios-组件化中的应用与管控",children:[]}],filePathRelative:"iOS/interview/1-category-and-extension.md",git:{updatedTime:1633942617e3,contributors:[{name:"peak",email:"peak@jiemogame.com",commits:1}]}}},7734:(e,n,a)=>{a.r(n),a.d(n,{default:()=>d});var s=a(6252);const r=(0,s.uE)('<h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3><h4 id="category" tabindex="-1"><a class="header-anchor" href="#category" aria-hidden="true">#</a> Category</h4><blockquote><p>是OC中的特有语法，它是表示一个指向分类的结构体的指针。原则上它只能增加方法，不能增加成员（实例）变量。</p></blockquote><h5 id="形式" tabindex="-1"><a class="header-anchor" href="#形式" aria-hidden="true">#</a> 形式</h5><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>@interface MyClass (MyCatetory)\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h5 id="作用" tabindex="-1"><a class="header-anchor" href="#作用" aria-hidden="true">#</a> 作用</h5><ul><li>分类是用于给原有类添加方法的, 因为分类的结构体指针中，没有属性列表，只有方法列表。所以原则上讲它只能添加方法, 不能添加属性(成员变量), 实际上可以通过其它方式添加属性;</li><li>分类中的可以写 <code>@property</code>, 但不会生成 <code>setter</code> 和 <code>getter</code> 方法, 也不会生成实现以及私有的成员变量（<code>编译时会报警告</code>）;</li><li>可以在分类中访问原有类中 <code>.h</code> 中的属性;</li><li>如果分类中有和原有类同名的方法, 会优先调用分类中的方法, 就是说会忽略原有类的方法。所以同名方法调用的优先级为 <code>分类 &gt; 本类 &gt; 父类</code>。因此在开发中尽量不要覆盖原有类;</li><li>如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定；编译器会执行最后一个参与编译的分类中的方法。</li></ul><p>在一个类中用 <code>@property</code> 声明属性，编译器会自动帮我们生成 <code>_成员变量</code>、 <code>setter</code> 和 <code>getter</code> 方法，</p><p>但分类的指针结构体中根本没有属性列表，所以在分类中用 <code>@property</code> 声明属性无法帮生成 <code>_成员变量</code>、 <code>setter</code> 和 <code>getter</code> 方法</p><p>因此结论是：我们可以用 <code>@property</code> 声明属性，编译和运行都会通过，只要不使用程序也不会崩溃。但如果调用了 <code>_成员变量</code> 和 <code>setter</code> 和 <code>getter</code> 方法，报错就在所难免了。</p><p><code>Category</code> 是表示一个指向分类的结构体的指针，其定义如下：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>typedef struct objc_category *Category;\nstruct objc_category {\n  char *category_name                          OBJC2_UNAVAILABLE; // 分类名\n  char *class_name                             OBJC2_UNAVAILABLE; // 分类所属的类名\n  struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE; // 实例方法列表\n  struct objc_method_list *class_methods       OBJC2_UNAVAILABLE; // 类方法列表\n  struct objc_protocol_list *protocols         OBJC2_UNAVAILABLE; // 分类所实现的协议列表\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="extension" tabindex="-1"><a class="header-anchor" href="#extension" aria-hidden="true">#</a> Extension</h4><blockquote><p>Extension是Category的一个特例。 类扩展与分类相比只少了分类的名称，所以称之为“匿名分类”。</p></blockquote><h5 id="形式-1" tabindex="-1"><a class="header-anchor" href="#形式-1" aria-hidden="true">#</a> 形式</h5><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>@interface XXX ()\n//私有属性\n//私有方法（如果不实现，编译时会报警,Method definition for &#39;XXX&#39; not found）\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="作用-1" tabindex="-1"><a class="header-anchor" href="#作用-1" aria-hidden="true">#</a> 作用</h5><ul><li>为一个类添加额外的原来没有变量，方法和属性</li><li>一般的类扩展写到.m文件中</li><li>一般的私有属性写到.m文件中的类扩展中</li></ul><h4 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h4><ul><li>分类中原则上只能增加方法（能添加属性的的原因是通过 runtime 解决无 setter 和 getter 方法的问题）；</li><li>扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（ 用范围只能在自身类，而不是子类或其他地方）；</li><li>类扩展中声明的方法没被实现，编译器会报警，但是分类中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而分类是在运行时添加到类中。(<code>Xcode9 也会警告</code>)</li><li>类扩展不能像分类那样拥有独立的实现部分（<code>@implementation</code> 部分），类扩展所声明的方法必须依托<strong>对应类</strong>的实现部分来实现。</li><li>定义在 <code>.m</code> 文件中的类扩展方法为私有的，定义在 <code>.h</code> 文件（头文件）中的类扩展方法为公有的。类扩展是在 .m 文件中声明私有方法的非常好的方式。</li></ul><h3 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题" aria-hidden="true">#</a> 常见问题</h3><h4 id="_1-分类为什么会覆盖掉类的同名方法-对应的类方法是不存在了么" tabindex="-1"><a class="header-anchor" href="#_1-分类为什么会覆盖掉类的同名方法-对应的类方法是不存在了么" aria-hidden="true">#</a> 1. 分类为什么会覆盖掉类的同名方法，对应的类方法是不存在了么？</h4><p>category 没有 <strong>完全替换掉</strong> 原来类已经有的方法，也就是说如果 category 和原来类都有 methodA ，那么 category 附加完成之后，类的方法列表里会有两个methodA;</p><p>category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面;</p><p>这也就是我们平常所说的 category 的方法会 <strong>覆盖</strong> 掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法就会罢休，殊不知后面可能还有一样名字的方法。</p><h4 id="_2-怎么解除分类对类方法的覆盖" tabindex="-1"><a class="header-anchor" href="#_2-怎么解除分类对类方法的覆盖" aria-hidden="true">#</a> 2. 怎么解除分类对类方法的覆盖？</h4><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>/**\n怎么调用到原来类中被 category 覆盖掉的方法？\n对于这个问题，我们已经知道 category 其实并不是完全替换掉原来类的同名方法，只是 category 在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：\n*/\n+ (void)useClassMethodInsteadCayegoryMethod:(SEL)seletor {\n    \n    if (self) {\n        unsigned int methodCount;\n        Method *methodList = class_copyMethodList([self class], &amp;methodCount);\n        IMP lastImp = NULL;\n        SEL lastSel = NULL;\n        for (NSInteger i = 0; i &lt; methodCount; i++) {\n            Method method = methodList[i];\n            NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method))\n                                                      encoding:NSUTF8StringEncoding];\n            NSString *selectorName = NSStringFromSelector(seletor);\n            if ([selectorName isEqualToString:methodName]) {\n                lastImp = method_getImplementation(method);\n                lastSel = method_getName(method);\n            }\n        }\n        typedef void (*fn)(id,SEL);\n        \n        if (lastImp != NULL) {\n            fn f = (fn)lastImp;\n            f(self,lastSel);\n        }\n        free(methodList);\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h4 id="_3-category关联对象" tabindex="-1"><a class="header-anchor" href="#_3-category关联对象" aria-hidden="true">#</a> 3. category关联对象</h4><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>#import &lt;Foundation/Foundation.h&gt;\n#import &quot;LearnCategoryClass.h&quot;\n\n@interface LearnCategoryClass (Addition)\n@property(nonatomic, strong) NSString *newName;\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>#import &quot;LearnCategoryClass+Addition.h&quot;\n#import &lt;objc/runtime.h&gt;\n\n@implementation LearnCategoryClass (Addition)\n\n//运行时动态添加 set 和 get 方法\n- (void)setNewName:(NSString *)newName\n{\n    objc_setAssociatedObject(self,\n                             &quot;newName&quot;,\n                             newName,\n                             OBJC_ASSOCIATION_COPY);\n}\n\n- (NSString*)newName\n{\n    NSString *nameObject = objc_getAssociatedObject(self, &quot;newName&quot;);\n    return nameObject;\n}\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h4 id="_4-多个category-哪个方法优先执行" tabindex="-1"><a class="header-anchor" href="#_4-多个category-哪个方法优先执行" aria-hidden="true">#</a> 4. 多个category，哪个方法优先执行？</h4><p>加载 <code>category</code> 到类的工作会先于<code>+load</code> 方法的执行；</p><p><code>+load</code> 方法执行的循序是先 <code>class</code>，后 <code>category</code>，多个 <code>category</code> 的 <code>+load</code> 方法的执行顺序是根据编译顺序决定的。</p><h3 id="category-特性在-ios-组件化中的应用与管控" tabindex="-1"><a class="header-anchor" href="#category-特性在-ios-组件化中的应用与管控" aria-hidden="true">#</a> Category 特性在 iOS 组件化中的应用与管控</h3><h5 id="实际业务案例" tabindex="-1"><a class="header-anchor" href="#实际业务案例" aria-hidden="true">#</a> 实际业务案例</h5><blockquote><p>例1：外卖的首页的商家列表（WMPageKit），在进入一个商家（WMRestaurantKit）选择5件商品返回到首页的时候，对应的商家cell需要显示已选商品“5”。</p></blockquote><blockquote><p>例2：搜索结果（WMSearchKit）跳转到商超的容器页（WMSupermarketKit），需要传递一个通用Domain（也有的说法叫模型、Model、Entity、Object等等，下文统一用Domain表示）。</p></blockquote><blockquote><p>例3：做一键下单需求（WMPageKit），需要调用下单功能的一个方法（WMOrderKit）入参是一个订单相关 Domain 和一个 VC，不需要返回值。</p></blockquote><p>这几种场景基本涵盖了组件通信所需的的基本功能，那么怎样才可以实现最优雅的解决方案？</p><h5 id="组件通信方案" tabindex="-1"><a class="header-anchor" href="#组件通信方案" aria-hidden="true">#</a> 组件通信方案</h5><h5 id="_1-category-nsinvocation方案" tabindex="-1"><a class="header-anchor" href="#_1-category-nsinvocation方案" aria-hidden="true">#</a> 1. Category+NSInvocation方案</h5><p>这个方案将其对 NSInvocation 功能容错封装、参数判断、类型转换的代码写在下层，提供简易万能的接口。并在上层创建通信调度器类提供常用接口，在调度器的的 Category 里扩展特定业务的专用接口。所有的上层接口均有规范约束，这些规范接口的内部会调用下层的简易万能接口即可通过NSInvocation 相关的硬编码操作调用任何方法。</p><p><img src="https://p0.meituan.net/travelcube/1a59d7f90ea57058226929a3f9aab257133322.png" alt="UML图"></p><p>示例代码:</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMScheduler+AKit.h\n#import &quot;WMScheduler.h&quot;\n@interface WMScheduler(AKit)\n/**\n * 通过商家id查到当前购物车已选e的小红点数量\n * @param poiid  商家id\n * @return 实际的小红点数量\n */\n+ (NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber *)poiID;\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMScheduler+AKit.m\n#import &quot;WMSchedulerCore.h&quot;\n#import &quot;WMScheduler+AKit.h&quot;\n#import &quot;NSObject+WMScheduler.h&quot;\n@implementation WMScheduler (AKit)\n+ (NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber *)poiID{\n    if (nil == poiid) {\n        return 0;\n    }\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;\n    id singleton = [wm_scheduler_getClass(&quot;WMXXXSingleton&quot;) wm_executeMethod:@selector(sharedInstance)];\n    NSNumber* orderFoodCount = [singleton wm_executeMethod:@selector(calculateOrderedFoodCountWithPoiID:) params:@[poiID]];\n    return orderFoodCount == nil ? 0 : [orderFoodCount integerValue];\n#pragma clang diagnostic pop\n}\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMSchedulerInterfaceList.h\n#ifndef WMSchedulerInterfaceList_h\n#define WMSchedulerInterfaceList_h\n// 这个文件会被加到上层业务的pch里，所以下文不用import本文件\n#import &quot;WMScheduler.h&quot;\n#import &quot;WMScheduler+AKit.h&quot;\n#endif /* WMSchedulerInterfaceList_h */\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>BKit （调用方）一个文件：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMHomeVC.m\n@interface WMHomeVC () &lt;UITableViewDataSource, UITableViewDelegate&gt;\n@end\n@implementation WMHomeVC\n...\n    NSUInteger *foodCount = [WMScheduler wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];\n    NSLog(@&quot;%ld&quot;,foodCount);\n...\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>阶段总结：</strong></p><p>Category+NSInvocation 方案的优点是便捷，因为 Category 的专用接口放在平台库，以后有除了 BKit 以外的其他调用方也可以直接调用，还有更多强大的功能。</p><p>但是，不优雅的地方我们也列举一下：</p><ul><li>当这个跨组件方法内部的代码行数比较多时，会写很多硬编码。</li><li>硬编码method字符串，在现有方法被修改时，编译检测不报错（只能靠断言约束）。</li><li>下层库向上调用的设计会被诟病。</li></ul><h5 id="_2-categorycoverorigin方案" tabindex="-1"><a class="header-anchor" href="#_2-categorycoverorigin方案" aria-hidden="true">#</a> 2. CategoryCoverOrigin方案</h5><p><strong>方案简介：</strong></p><p>首先说明下这个方案和 NSInvocation 没有任何关系，此方案与上一方案也是完全不同的两个概念，不要将上一个方案的思维带到这里。</p><p>此方案的思路是在平台层的 WMScheduler.h 提供接口方法，接口的实现只写空实现或者兜底实现（兜底实现中可根据业务场景在 Debug 环境下增加 toast 提示或断言），上层库的提供方实现接口方法并通过 Category 的特性，在运行时进行对基类同名方法的替换。</p><p>调用方则正常调用平台层提供的接口。在 CategoryCoverOrigin 的方案中 WMScheduler 的 Category 在提供方仓库内部，因此业务逻辑的依赖可以在仓库内部使用常规的OC调用。</p><p><img src="https://p0.meituan.net/travelcube/577bb3b451cc26f621fbedc15118e3dc95493.png" alt="UML"></p><p>平台（通用功能库）两个文件</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>//  WMScheduler.h\n@interface WMScheduler : NSObject\n//  这个文件是所有组件通信方法的汇总\n#pragma mark - AKit  \n/**\n * 通过商家id查到当前购物车已选e的小红点数量\n * @param poiid  商家id\n * @return 实际的小红点数量\n */\n+ (NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber *)poiID;\n#pragma mark - CKit\n// ...\n#pragma mark - DKit\n// ...\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMScheduler.m\n#import &quot;WMScheduler.h&quot;\n@implementation WMScheduler\n#pragma mark - Akit\n+ (NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber *)poiID\n{\n\t\treturn 0; // 这个.m里只要求一个空实现 作为兜底方案。\n}\n#pragma mark - Ckit\n// ...\n#pragma mark - Dkit\n// ...\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>AKit（提供方）一个 Category 文件：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMScheduler+AKit.m\n#import &quot;WMScheduler.h&quot;\n#import &quot;WMAKitBusinessManager.h&quot;\n#import &quot;WMXXXSingleton.h&quot;  \n// 直接导入了很多AKit相关的业务文件，因为本身就在AKit仓库内\n@implementation WMScheduler (AKit)\n// 这个宏可以屏蔽分类覆盖基类方法的警告\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored &quot;-Wobjc-protocol-method-implementation&quot;\n// 在平台层写过的方法，这边是是自动补全的\n+ (NSUInteger)wms_getOrderedFoodCountWithPoiID:(NSNumber *)poiID\n{\n  \tif (nil == poiid) {\n        return 0;\n    }\n  \t// 所有AKIT相关的类都能直接接口调用，不需要任何硬编码，可以和之前的写法对比下。\n    WMXXXSingleton *singleton = [WMXXXSingleton sharedInstance];\n    NSNumber *orderFoodCount = [singleton calculateOrderedFoodCountWithPoiID:poiID];\n    return orderFoodCount == nil ? 0 : [orderFoodCount integerValue];\n}\n#pragma clang diagnostic pop\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>BKit（调用方） 一个文件写法不变：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// WMHomeVC.m\n@interface WMHomeVC () &lt;UITableViewDataSource, UITableViewDelegate&gt;\n@end\n@implementation WMHomeVC\n...\n    NSUInteger *foodCount = [WMScheduler wms_getOrderedFoodCountWithPoiID:currentPoi.poiID];\n    NSLog(@&quot;%ld&quot;,foodCount);\n...\n@end\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>两种方案的选择</p><table><thead><tr><th>比较</th><th>Category+NSInvocation</th><th>CategoryCover</th></tr></thead><tbody><tr><td>优点</td><td>1. 只改两个仓库，流程上的时间成本更少；<br>2. 可以实现url调用方法（scheme://target/method:?para=x）</td><td>1. 无任何硬编码，常规OC接口调用；<br>2. 除了接口声明、分类覆盖、调用，没有其他多余代码；不存在下层调用上层的场景</td></tr><tr><td>缺点</td><td>1. 功能复杂时硬编码写法成本较大；<br>2. 下层调上层，上层业务改变时会影响平台接口</td><td>1. 不能使用url调用方法；<br> 2. 新增接口时需改动三个仓库，稍有麻烦。（当接口已存在时，两种方式都只需修改一处）</td></tr></tbody></table><p><strong>内容来源:</strong></p>',69),l={href:"https://www.jianshu.com/p/9e827a1708c6",target:"_blank",rel:"noopener noreferrer"},i=(0,s.Uk)("1. iOS分类(category),类扩展(extension)—史上最全攻略"),t={href:"https://www.jianshu.com/p/a057936e0dac",target:"_blank",rel:"noopener noreferrer"},o=(0,s.Uk)("2. category的高级使用"),c={href:"https://tech.meituan.com/2018/11/08/ios-category-module-communicate.html",target:"_blank",rel:"noopener noreferrer"},p=(0,s.Uk)("3. Category 特性在 iOS 组件化中的应用与管控"),b={},d=(0,a(3744).Z)(b,[["render",function(e,n){const a=(0,s.up)("OutboundLink");return(0,s.wg)(),(0,s.iD)(s.HY,null,[r,(0,s._)("p",null,[(0,s._)("a",l,[i,(0,s.Wm)(a)])]),(0,s._)("p",null,[(0,s._)("a",t,[o,(0,s.Wm)(a)])]),(0,s._)("p",null,[(0,s._)("a",c,[p,(0,s.Wm)(a)])])],64)}]])},3744:(e,n)=>{n.Z=(e,n)=>{for(const[a,s]of n)e[a]=s;return e}}}]);