"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[194],{8211:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-5fdf1664",path:"/data-structure/xor.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"data-structure/xor.md",git:{updatedTime:1633942617e3,contributors:[{name:"peak",email:"peak@jiemogame.com",commits:1}]}}},7600:(n,a,s)=>{s.r(a),s.d(a,{default:()=>d});var e=s(6252);const r=(0,e.uE)('<h4 id="xor运算" tabindex="-1"><a class="header-anchor" href="#xor运算" aria-hidden="true">#</a> XOR运算</h4><p><code>XOR</code>运算，中文称为“异或运算”。</p><p>它的定义是：两个值相同时，返回 0，否则返回 1。</p><table><thead><tr><th>x</th><th>y</th><th>x^y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><h4 id="运算定律" tabindex="-1"><a class="header-anchor" href="#运算定律" aria-hidden="true">#</a> 运算定律</h4><h5 id="一个值与自身的运算结果为-0" tabindex="-1"><a class="header-anchor" href="#一个值与自身的运算结果为-0" aria-hidden="true">#</a> 一个值与自身的运算结果为 0</h5><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>x <span class="token operator">^</span> x <span class="token operator">=</span> <span class="token number">0</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h5 id="一个值与-0-的运算结果为本身" tabindex="-1"><a class="header-anchor" href="#一个值与-0-的运算结果为本身" aria-hidden="true">#</a> 一个值与 0 的运算结果为本身</h5><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>x <span class="token operator">^</span> <span class="token number">0</span> <span class="token operator">=</span> x\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h5 id="可交换性" tabindex="-1"><a class="header-anchor" href="#可交换性" aria-hidden="true">#</a> 可交换性</h5><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>x <span class="token operator">^</span> y <span class="token operator">=</span> y <span class="token operator">^</span> x\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h4 id="xor-应用" tabindex="-1"><a class="header-anchor" href="#xor-应用" aria-hidden="true">#</a> XOR 应用</h4><h5 id="_1-原地交换" tabindex="-1"><a class="header-anchor" href="#_1-原地交换" aria-hidden="true">#</a> 1. 原地交换</h5><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>x <span class="token operator">^=</span> y\ny <span class="token operator">^=</span> x\nx <span class="token operator">^=</span> y\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>计算展开过程如下：</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>x <span class="token operator">^=</span> y\n<span class="token comment">// x = x ^ y</span>\n<span class="token comment">// y = y</span>\n\ny <span class="token operator">^=</span> x\n<span class="token comment">// x = x ^ y</span>\n<span class="token comment">// y = x ^ y ^ x = x</span>\n\nx <span class="token operator">^=</span> y\n<span class="token comment">// x = x ^ y ^ y = x</span>\n<span class="token comment">// y = x</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h5 id="_2-加-解密" tabindex="-1"><a class="header-anchor" href="#_2-加-解密" aria-hidden="true">#</a> 2. 加/解密</h5><ul><li>明文（text）与 密钥（key）进行异或运算，可以得到密文（cipherText）</li><li>密文（cipherText）与 密钥（key）进行异或运算，可以得到明文（text）</li></ul><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>text <span class="token operator">^</span> key <span class="token operator">=</span> cipherText\ncipherText <span class="token operator">^</span> key <span class="token operator">=</span> text\n<span class="token comment">// text ^ key ^ key </span>\n<span class="token comment">// 0 ^ text</span>\n<span class="token comment">// text</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="_3-面试题" tabindex="-1"><a class="header-anchor" href="#_3-面试题" aria-hidden="true">#</a> 3. 面试题</h5><h6 id="_1-查找缺失的数字" tabindex="-1"><a class="header-anchor" href="#_1-查找缺失的数字" aria-hidden="true">#</a> 1. 查找缺失的数字</h6><blockquote><p>给定一个包含 n-1个 元素的数组A， 元素的取值范围是 1 到 n 且没有重复，找出缺少的那个数字</p></blockquote><p>解决方案：把数组中的每个元素和 1 到 n 的整数进行异或运算，结果就是缺少的数字</p><blockquote><p>1 ^ 2 ^ ... ^ n ^ A[0] ^ A[1] ... A[n - 2]</p></blockquote><p>原理：</p><ul><li><p>出现 2 次的数字，异或之后结果是0</p></li><li><p>缺失的数字出现一次，和 0 进行异或之后，结果是它本身</p></li></ul><h6 id="_2-查找重复的数字" tabindex="-1"><a class="header-anchor" href="#_2-查找重复的数字" aria-hidden="true">#</a> 2. 查找重复的数字</h6><blockquote><p>给定一个包含 n + 1个 元素的数组A， 元素的取值范围是 1 到 n 且只有一个数字重复，找出重复的那个数字</p></blockquote><p>解决方案：把数组中的每个元素和 1 到 n 的整数进行异或运算，结果就是重复的数字</p><blockquote><p>1 ^ 2 ^ ... ^ n ^ A[0] ^ A[1] ... A[n]</p></blockquote><p>原理：</p><ul><li><p>出现 2 次的数字，异或之后结果是0</p></li><li><p>重复的数字出现 3 次，异或之后，结果是它本身</p></li></ul><h4 id="代码片段" tabindex="-1"><a class="header-anchor" href="#代码片段" aria-hidden="true">#</a> 代码片段</h4><p>iOS加密数据如下：</p><p>循环遍历数据中的每一个字节，每个字节对应的数据与加密key对应的值做异或运算，然后把异或后的数据与原数据做交换。</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (NSData *)obfuscate:(NSData *)data withKey:(NSString *)key\n{\n     NSMutableData *result = [data mutableCopy];\n    char *dataPtr = (char *) [result mutableBytes];\n    char *keyData = (char *) [[key dataUsingEncoding:NSUTF8StringEncoding] bytes];\n    char *keyPtr = keyData;\n    int keyIndex = 0;\n\n    // For each character in data, xor with current value in key\n    for (int x = 0; x &lt; [data length]; x++) \n    {\n        *dataPtr = *dataPtr ^ *keyPtr;\n        dataPtr++;\n        keyPtr++; \n\n        // If at end of key data, reset count and \n        // set key pointer back to start of key value\n        if (++keyIndex == [key length]) {\n        \tkeyIndex = 0;\n        \tkeyPtr = keyData;\n        }\n    }\n    return result;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>查找缺失的数字</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">find_missing</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>\n  result <span class="token operator">=</span> <span class="token number">0</span>\n\n  <span class="token comment"># Add all the values from 1 to n</span>\n  <span class="token keyword">for</span> value <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>\n    result <span class="token operator">+=</span> value\n\n  <span class="token comment"># Subtract all values in the given array</span>\n  <span class="token keyword">for</span> value <span class="token keyword">in</span> A<span class="token punctuation">:</span>\n    result <span class="token operator">-=</span> value\n\n  <span class="token keyword">return</span> result\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h4>',39),t={href:"http://www.ruanyifeng.com/blog/2017/05/xor.html",target:"_blank",rel:"noopener noreferrer"},p=(0,e.Uk)("XOR 加密简介"),l={href:"https://stackoverflow.com/questions/11724527/xor-file-encryption-in-ios",target:"_blank",rel:"noopener noreferrer"},c=(0,e.Uk)("xor-file-encryption-in-ios"),o={href:"https://florian.github.io/xor-trick/",target:"_blank",rel:"noopener noreferrer"},i=(0,e.Uk)("xor-trick"),u={},d=(0,s(3744).Z)(u,[["render",function(n,a){const s=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[r,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e._)("a",t,[p,(0,e.Wm)(s)])]),(0,e._)("li",null,[(0,e._)("a",l,[c,(0,e.Wm)(s)])]),(0,e._)("li",null,[(0,e._)("a",o,[i,(0,e.Wm)(s)])])])],64)}]])},3744:(n,a)=>{a.Z=(n,a)=>{for(const[s,e]of a)n[s]=e;return n}}}]);