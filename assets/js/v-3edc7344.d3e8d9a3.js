"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8008],{2172:(n,e,a)=>{a.r(e),a.d(e,{data:()=>s});const s={key:"v-3edc7344",path:"/iOS/interview/3-weak.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"iOS/interview/3-weak.md",git:{updatedTime:1633942617e3,contributors:[{name:"peak",email:"peak@jiemogame.com",commits:1}]}}},4649:(n,e,a)=>{a.r(e),a.d(e,{default:()=>W});var s=a(6252);const l=(0,s.uE)('<p>weak 的用处用一句话可归纳为：<strong>弱引用，在对象释放后置为 nil，避免错误的内存访问</strong>。<br>用更通俗的话来表述是：weak 可以在不增加对象的引用计数的同时，又使得指针的访问是安全的。</p><h4 id="实现weak后-为什么对象释放后会自动为nil" tabindex="-1"><a class="header-anchor" href="#实现weak后-为什么对象释放后会自动为nil" aria-hidden="true">#</a> 实现weak后，为什么对象释放后会自动为nil</h4><p><code>runtime</code> 对注册的类， 会进行布局，对于 weak 对象会放入一个 <code>hash</code> 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 <code>nil</code> 。</p><h4 id="当weak引用指向的对象被释放时-又是如何去处理weak指针的呢" tabindex="-1"><a class="header-anchor" href="#当weak引用指向的对象被释放时-又是如何去处理weak指针的呢" aria-hidden="true">#</a> 当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？</h4><ol><li>调用 objc_release</li><li>因为对象的引用计数为0，所以执行 dealloc</li><li>在 dealloc中，调用了_objc_rootDealloc 函数</li><li>在 _objc_rootDealloc 中，调用了object_dispose 函数</li><li>调用 objc_destructInstance</li><li>最后调用 objc_clear_deallocating,详细过程如下：</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>a. 从weak表中获取废弃对象的地址为键值的记录\nb. 将包含在记录中的所有附有 weak 修饰符变量的地址，赋值为 nil\nc. 将 weak 表中该记录删除\nd. 从引用计数表中删除废弃对象的地址为键值的记录\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="weak实现原理" tabindex="-1"><a class="header-anchor" href="#weak实现原理" aria-hidden="true">#</a> weak实现原理：</h4><p><code>Runtime</code> 维护了一个 weak 表，用于存储指向某个对象的所有 weak 指针。weak 表其实是一个hash（哈希）表，key 是所指对象的地址，value 是 weak 指针的地址（这个地址的值是所指对象指针的地址）数组。</p><ol><li>初始化时：runtime 会调用 <code>objc_initWeak</code> 函数，初始化一个新的 weak 指针指向对象的地址。</li><li>添加引用时：<code>objc_initWeak </code>函数会调用 <code>objc_storeWeak()</code> 函数， <code>objc_storeWeak()</code> 的作用是更新指针指向，创建对应的弱引用表。</li><li>释放时，调用 <code>clearDeallocating</code> 函数。<code>clearDeallocating</code> 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。</li></ol><h4 id="sidetable" tabindex="-1"><a class="header-anchor" href="#sidetable" aria-hidden="true">#</a> SideTable</h4>',10),c=(0,s._)("code",null,"SideTable ",-1),r=(0,s.Uk)("是一个用 "),t=(0,s._)("code",null,"C++",-1),o=(0,s.Uk)(" 实现的类，它的具体定义在"),i={href:"https://opensource.apple.com/source/objc4/objc4-532.2/runtime/NSObject.mm",target:"_blank",rel:"noopener noreferrer"},p=(0,s.Uk)("NSObject.mm"),u=(0,s.Uk)("中, 它主要用于管理对象的引用计数和 weak 表。在 NSObject.mm 中声明其数据结构："),b=(0,s.uE)('<div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">SideTable</span> <span class="token punctuation">{</span>\n\t<span class="token comment">// 保证原子操作的自旋锁</span>\n    <span class="token class-name">spinlock_t</span> slock<span class="token punctuation">;</span>\n    <span class="token comment">// 引用计数的 hash 表</span>\n    RefcountMap refcnts<span class="token punctuation">;</span>\n    <span class="token comment">// weak 引用全局 hash 表</span>\n    <span class="token class-name">weak_table_t</span> weak_table<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>',1),k=(0,s.Uk)("weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了某个对象相关的的所有的弱引用信息。其定义如下(具体定义在"),d={href:"https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h",target:"_blank",rel:"noopener noreferrer"},m=(0,s.Uk)("objc-weak.h"),h=(0,s.Uk)("中)："),w=(0,s.uE)('<div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">weak_table_t</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 保存了所有指向指定对象的 weak 指针</span>\n    <span class="token class-name">weak_entry_t</span> <span class="token operator">*</span>weak_entries<span class="token punctuation">;</span>\n    <span class="token comment">// 存储空间</span>\n    <span class="token class-name">size_t</span>    num_entries<span class="token punctuation">;</span>\n    <span class="token comment">// 参与判断引用计数辅助量</span>\n    <span class="token class-name">uintptr_t</span> mask<span class="token punctuation">;</span>\n    <span class="token comment">// hash key 最大偏移值</span>\n    <span class="token class-name">uintptr_t</span> max_hash_displacement<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="weak-singleton" tabindex="-1"><a class="header-anchor" href="#weak-singleton" aria-hidden="true">#</a> weak singleton</h4><p>在所有使用该单例的对象都释放后，单例对象本身也会自己释放。我所见过的大部分单例使用场景，被创建都单例最后都会一直存活着，比如注册登录模块所需要共享状态所创建的 <code>XXLoginManager</code>，即使在用户注册成功进入主界面之后也不会被显式的释放，这在一定程度上会带来内存使用的浪费。所谓的「<code>weak singleton</code>」代码很简单：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>+ (id)sharedInstance\n{\n    static __weak ASingletonClass *instance;\n    ASingletonClass *strongInstance = instance;\n    @synchronized(self) {\n        if (strongInstance == nil) {\n            strongInstance = [[[self class] alloc] init];\n            instance = strongInstance;\n        }\n    }\n    return strongInstance;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>Controller A， B， C 都可以持有 <code>ASingletonClass</code> 的强引用，一旦 A，B，C 都销毁后，<code>ASingletonClass</code> 的单例对象也会随之销毁，略巧妙不是吗？</p><p>「weak singleton」这个漂亮名字背后其实只是简单而巧妙的利用了 weak 特性，sharedInstance 中的 weak 就像是一个智能管家，在无人使用 instance 之后就置为 nil 销毁，当 sharedInstance 再次被调用时，instance 又会重新被创建。</p><h4 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h4>',7),_={href:"http://mrpeak.cn/blog/ios-weak/",target:"_blank",rel:"noopener noreferrer"},g=(0,s.Uk)("iOS weak 关键字漫谈"),f={href:"https://www.jianshu.com/p/7c6400a04e58",target:"_blank",rel:"noopener noreferrer"},j=(0,s.Uk)("iOS-实现weak后，为什么对象释放后会自动为nil"),v={href:"https://www.jianshu.com/p/13c4fb1cedea",target:"_blank",rel:"noopener noreferrer"},x=(0,s.Uk)("iOS 底层解析weak的实现原理"),S={href:"http://zhoulingyu.com/2017/02/15/Advanced-iOS-Study-objc-Memory-2/",target:"_blank",rel:"noopener noreferrer"},C=(0,s.Uk)("iOS（Objective-C）内存管理"),y={href:"http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/",target:"_blank",rel:"noopener noreferrer"},O=(0,s.Uk)("Objective-C 引用计数原理"),U={},W=(0,a(3744).Z)(U,[["render",function(n,e){const a=(0,s.up)("OutboundLink");return(0,s.wg)(),(0,s.iD)(s.HY,null,[l,(0,s._)("p",null,[c,r,t,o,(0,s._)("a",i,[p,(0,s.Wm)(a)]),u]),b,(0,s._)("p",null,[k,(0,s._)("a",d,[m,(0,s.Wm)(a)]),h]),w,(0,s._)("ol",null,[(0,s._)("li",null,[(0,s._)("a",_,[g,(0,s.Wm)(a)])]),(0,s._)("li",null,[(0,s._)("a",f,[j,(0,s.Wm)(a)])]),(0,s._)("li",null,[(0,s._)("a",v,[x,(0,s.Wm)(a)])]),(0,s._)("li",null,[(0,s._)("a",S,[C,(0,s.Wm)(a)])]),(0,s._)("li",null,[(0,s._)("a",y,[O,(0,s.Wm)(a)])])])],64)}]])},3744:(n,e)=>{e.Z=(n,e)=>{for(const[a,s]of e)n[a]=s;return n}}}]);