"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4365],{8575:(e,a,n)=>{n.r(a),n.d(a,{data:()=>t});const t={key:"v-8f34aea2",path:"/shell/nohup.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"shell/nohup.md",git:{updatedTime:1633942617e3,contributors:[{name:"peak",email:"peak@jiemogame.com",commits:1}]}}},6750:(e,a,n)=>{n.r(a),n.d(a,{default:()=>i});const t=(0,n(6252).uE)('<p align="right">2019-7-18</p><h4 id="场景" tabindex="-1"><a class="header-anchor" href="#场景" aria-hidden="true">#</a> 场景</h4><p>如何在后台长时间运行某个命令？</p><h5 id="nohup" tabindex="-1"><a class="header-anchor" href="#nohup" aria-hidden="true">#</a> nohup</h5><p>nohup 的主要作用是让提交的命令忽略 hangup 信号。具体帮助信息如下:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>nohup -- invoke a utility immune to hangups\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h4 id="语法" tabindex="-1"><a class="header-anchor" href="#语法" aria-hidden="true">#</a> 语法</h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>nohup command &amp;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>nohup 会将标准输出和标准错误重定向到 nohup.out 文件中。在结尾添加 <code>&amp;</code> 符号会将命令同时放入后台运行。</p><h4 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h4><p>在后台执行 <code>ping www.baidu.com</code> 命令， 执行结果会输出当当前文件夹下的 <code>nohup.out</code> 文件中。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>nohup ping www.baidu.com &amp;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>',12),d={},i=(0,n(3744).Z)(d,[["render",function(e,a){return t}]])},3744:(e,a)=>{a.Z=(e,a)=>{for(const[n,t]of a)e[n]=t;return e}}}]);