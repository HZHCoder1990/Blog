"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[661],{9384:(n,e,a)=>{a.r(e),a.d(e,{data:()=>s});const s={key:"v-3b644ce6",path:"/iOS/multiple-thread.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"多线程技术方案",slug:"多线程技术方案",children:[{level:3,title:"1.pthread",slug:"_1-pthread",children:[]},{level:3,title:"2.NSThread",slug:"_2-nsthread",children:[]},{level:3,title:"3.GCD",slug:"_3-gcd",children:[]}]}],filePathRelative:"iOS/multiple-thread.md",git:{updatedTime:1633942617e3,contributors:[{name:"peak",email:"peak@jiemogame.com",commits:1}]}}},7776:(n,e,a)=>{a.r(e),a.d(e,{default:()=>i});var s=a(6252);const r=(0,s.uE)('<h2 id="多线程技术方案" tabindex="-1"><a class="header-anchor" href="#多线程技术方案" aria-hidden="true">#</a> 多线程技术方案</h2><p><a href="#pthread">1. pthread</a></p><p><a href="#NSThread">2. NSThread</a></p><p><a href="#GCD">3. GCD</a></p><p><a href="#NSOperation">4. NSOperation</a></p><h3 id="_1-pthread" tabindex="-1"><a class="header-anchor" href="#_1-pthread" aria-hidden="true">#</a> <a name="pthread"></a>1.pthread</h3><p><strong>特点</strong></p><p>程序员自己管理线程的生命周期</p><p><strong>定义</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>线程库实行了POSIX线程标准通常称为Pthreads。\nPOSIX线程具有很好的可移植性，使用pthreads编写的代码可运行于Solaris、FreeBSD、Linux 等平台，Windows平台亦有pthreads-win32可供使用 。\nPthreads定义了一套C语言的类型、函数与常量，它以pthread.h头文件和一个线程库实现。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>头文件</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>#import &lt;pthread.h&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>创建线程</strong></p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>/**\n\n- (void)demo {\n\n    \n    //1.创建线程对象\n    pthread_t thread;\n    \n    /**2.创建线程\n    参数：\n     1.指向线程标识符的指针，C 语言中类型的结尾通常 _t/Ref，而且不需要使用 *;\n     2.用来设置线程属性;\n     3.指向函数的指针,传入函数名(函数的地址)，线程要执行的函数/任务;\n     4.运行函数的参数;\n     */\n    NSString *param = @&quot;参数&quot;;\n    int result = pthread_create(&amp;thread, NULL, func, (__bridge void *)(param));\n    if (result == 0) {\n    \tNSLog(@&quot;success&quot;)\n    } else {\n    \tNSLog(@&quot;failure&quot;);\n    \treturn;\n    }\n    \n    //3.设置子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源，或者在子线程中添加 pthread_detach(pthread_self()),其中pthread_self()是获得线程自身的id\n    pthread_detach(thread);\n }\n \n void *func(void *param) {\n\t//在此做耗时操作\n    NSLog(@&quot;new thread : %@  参数是: %@&quot;,[NSThread currentThread],(__bridge NSString *)(param));\n    \n    return NULL;\n }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p><strong>其他函数</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>pthread_t：线程ID\npthread_attr_t：线程属性\npthread_create()：创建一个线程\npthread_exit()：终止当前线程\npthread_cancel()：中断另外一个线程的运行\npthread_join()：阻塞当前的线程，直到另外一个线程运行结束\npthread_attr_init()：初始化线程的属性\npthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）\npthread_attr_getdetachstate()：获取脱离状态的属性\npthread_attr_destroy()：删除线程的属性\npthread_kill()：向线程发送一个信号\npthread_equal(): 对两个线程的线程标识号进行比较\npthread_detach(): 分离线程\npthread_self(): 查询线程自身线程标识号\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_2-nsthread" tabindex="-1"><a class="header-anchor" href="#_2-nsthread" aria-hidden="true">#</a> <a name="NSThread"></a>2.NSThread</h3><p><strong>特点</strong></p><p>程序员管理线程的生命周期；</p><p>使用OC对象， 简单易用，可直接操作线程对象</p><p><strong>创建方式</strong></p><p><strong>1. 实例方法创建线程</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (IBAction)useInstanceMehotd:(id)sender {\n    NSLog(@&quot;===== begin %@&quot;, [NSThread currentThread]);\n    // 创建NSThread 对象\n    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(myOperation:) object:@&quot;instance method&quot;];\n    // 启动线程 -&gt; 开辟子线程执行方法\n    [thread start];\n    NSLog(@&quot;===== end %@&quot;, [NSThread currentThread]);\n}\n\n- (void)myOperation:(id)param {\n    NSLog(@&quot;begin %@&quot;, [NSThread currentThread]);\n    NSLog(@&quot;param = %@&quot;, param);\n    [NSThread sleepForTimeInterval:3];\n    NSLog(@&quot;end %@&quot;, [NSThread currentThread]);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>2. 类方法创建线程</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (IBAction)useClassMethod:(id)sender {\n    NSLog(@&quot;===== begin %@&quot;, [NSThread currentThread]);\n    // 自动创建线程，并执行方法\n    [NSThread detachNewThreadSelector:@selector(myOperation:) toTarget:self withObject:@&quot;class method&quot;];\n    NSLog(@&quot;===== end %@&quot;, [NSThread currentThread]);\n\n}\n\n- (void)myOperation:(id)param {\n    NSLog(@&quot;begin %@&quot;, [NSThread currentThread]);\n    NSLog(@&quot;param = %@&quot;, param);\n    [NSThread sleepForTimeInterval:3];\n    NSLog(@&quot;end %@&quot;, [NSThread currentThread]);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>3. NSObject分类方法创建线程</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (IBAction)useCatgoryMethod:(id)sender {\n    NSLog(@&quot;===== begin %@&quot;, [NSThread currentThread]);\n    // 是NSObject分类方法\n    // 自动在后台线程执行\n    [self performSelectorInBackground:@selector(myOperation:) withObject:@&quot;category method&quot;];\n    NSLog(@&quot;===== end %@&quot;, [NSThread currentThread]);\n}\n\n- (void)myOperation:(id)param {\n    NSLog(@&quot;begin %@&quot;, [NSThread currentThread]);\n    NSLog(@&quot;param = %@&quot;, param);\n    [NSThread sleepForTimeInterval:3];\n    NSLog(@&quot;end %@&quot;, [NSThread currentThread]);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_3-gcd" tabindex="-1"><a class="header-anchor" href="#_3-gcd" aria-hidden="true">#</a> <a name="GCD"></a>3.GCD</h3><p><strong>特点</strong></p><p>不用关心线程的生命周期</p><p><strong>执行任务方式</strong></p><ol><li>同步的方式执行：</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\nqueue: 队列\nblock: 任务\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="2"><li>异步的方式执行</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);\nqueue: 队列\nblock: 任务\n\n\n同步：\n只能在当前线程中执行任务， 不具备开启线程能力\n必须等待任务执行完毕，才会执行下一条语句\n\n异步：\n可以在新的线程中执行， 具备开启新线程能力\n不用等待任务执行完毕， 就可以执行下一条语句\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>队列类型</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1. 并发队列(Concurrent Dispatch Queue)\n   * 允许多个任务并发（同时）执行\n   * 并发功能只有在异步函数下才有效\n2. 串行队列（Serial Dispatch Queue)\n   * 让任务一个接着一个的执行\n\n全局队列（dispatch_get_global_queue): 是一个并发队列\n主队列（dispatch_get_main_queue): 主队列专门用于在主线程上执行任务， 是一个串行队列\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>队列执行效果</strong></p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:left;">并发队列</th><th style="text-align:left;">串行队列</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>同步</strong></td><td style="text-align:left;">1.没有开启新线程<br>2.串行执行任务</td><td style="text-align:left;">1. 没有开启新线程<br>2. 串行执行任务</td></tr><tr><td style="text-align:center;"><strong>异步</strong></td><td style="text-align:left;">1. 开启新线程<br>2. 并发执行任务</td><td style="text-align:left;">1. 开启新线程<br>2. 串行执行任务</td></tr></tbody></table><h4 id="dispatch-barrier-async-使用" tabindex="-1"><a class="header-anchor" href="#dispatch-barrier-async-使用" aria-hidden="true">#</a> dispatch_barrier_async 使用</h4><blockquote><p>该函数会等待dispatch_barrier_async 前面所有任务完成</p></blockquote><blockquote><p>然后在执行 dispatch_barrier_async 的任务</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (IBAction)test_barrier_async:(id)sender {\n    dispatch_queue_t queue = dispatch_queue_create(&quot;com.chenxi.learn.thread&quot;, DISPATCH_QUEUE_CONCURRENT);\n    \n    dispatch_async(queue, ^{\n        [NSThread sleepForTimeInterval:2];\n        NSLog(@&quot;task1 complete, %@&quot;, [NSThread currentThread]);\n    });\n    \n    dispatch_async(queue, ^{\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@&quot;task2 complete, %@&quot;, [NSThread currentThread]);\n    });\n    \n    dispatch_async(queue, ^{\n        int time = arc4random() % 5;\n        [NSThread sleepForTimeInterval:time];\n        NSLog(@&quot;task3 complete, %@&quot;, [NSThread currentThread]);\n    });\n    \n    // 阻塞\n    dispatch_barrier_async(queue, ^{\n        NSLog(@&quot;barrier asycn task ..., %@&quot;, [NSThread currentThread]);\n    });\n    \n    dispatch_async(queue, ^{\n        [NSThread sleepForTimeInterval:3];\n        NSLog(@&quot;another task1 complete, %@&quot;, [NSThread currentThread]);\n    });\n    \n    dispatch_async(queue, ^{\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@&quot;another task2 complete, %@&quot;, [NSThread currentThread]);\n    });\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><h4 id="gcd-调度组" tabindex="-1"><a class="header-anchor" href="#gcd-调度组" aria-hidden="true">#</a> GCD 调度组</h4><blockquote><p>使用 dispatch_group_async 和 dispatch_group_notify 函数来完成调度组的工作</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (void)demo {\n    \n    // 1. 调度组\n    dispatch_group_t group = dispatch_group_create();\n    \n    // 2. 并发队列\n    dispatch_queue_t queue = dispatch_queue_create(&quot;com.chenxi.learn.thread&quot;, DISPATCH_QUEUE_CONCURRENT);\n    \n    // 3. 任务添加到调度组\n    dispatch_group_async(group, queue, ^{\n        [NSThread sleepForTimeInterval:3];\n        NSLog(@&quot;task1 comolete, %@&quot;, [NSThread currentThread]);\n    });\n    \n    dispatch_group_async(group, queue, ^{\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@&quot;task2 comolete, %@&quot;, [NSThread currentThread]);\n    });\n    \n    dispatch_group_async(group, queue, ^{\n        [NSThread sleepForTimeInterval:2];\n        NSLog(@&quot;task3 comolete, %@&quot;, [NSThread currentThread]);\n    });\n    \n    // 等待所有任务离开调度组， 调用该函数\n    dispatch_group_notify(group, dispatch_get_main_queue(), ^{\n        NSLog(@&quot;all task completed, %@&quot;, [NSThread currentThread]);\n    });\n    \n    NSLog(@&quot;other things ...&quot;);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h4 id="_4-nsoperation" tabindex="-1"><a class="header-anchor" href="#_4-nsoperation" aria-hidden="true">#</a> <a name="NSOperation"></a>4. NSOperation</h4><p><strong>特点</strong></p><blockquote><p>是使用OC语言对GCD的封装</p></blockquote><blockquote><p>完全面向对象，不需要管理线程的生命周期</p></blockquote><p>NSOperation 只是一个抽象类， 需要使用子类来执行任务。 苹果提供了两个子类： NSInvocationOperation 和 NSBlockOperation。</p><p><strong>核心</strong></p><blockquote><p>操作(NSoperation)： 要做的事情</p></blockquote><blockquote><p>队列(NSOperationQueue): 存放操作</p></blockquote><p><strong>使用步骤</strong></p><blockquote><p>创建操作</p></blockquote><blockquote><p>创建队列</p></blockquote><blockquote><p>将操作放入队列</p></blockquote><h5 id="nsinvocationoperation-使用" tabindex="-1"><a class="header-anchor" href="#nsinvocationoperation-使用" aria-hidden="true">#</a> NSInvocationOperation 使用</h5><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (IBAction)tes_invocation:(id)sender {\n    \n    NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo:) object:@{@&quot;name&quot;:@&quot;invocationOperation&quot;, @&quot;param&quot;: @&quot;hello world&quot;}];\n    \n    // 操作完成回调\n    [invocationOperation setCompletionBlock:^{\n        NSLog(@&quot;end invocation thread = %@&quot;, [NSThread currentThread]);\n    }];\n    \n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    \n    [queue addOperation:invocationOperation];\n}\n\n- (void)demo:(id)obj {\n    [NSThread sleepForTimeInterval:arc4random()%4];\n    NSLog(@&quot;thread = %@, msg = %@&quot;, [NSThread currentThread], obj);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h5 id="nsblockoperation" tabindex="-1"><a class="header-anchor" href="#nsblockoperation" aria-hidden="true">#</a> NSBlockOperation</h5><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (IBAction)test_block:(id)sender {\n    \n    NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{\n        [NSThread sleepForTimeInterval:3];\n        NSLog(@&quot;block operation 1, thread = %@&quot;, [NSThread currentThread]);\n    }];\n    \n    // 可以添加多个任务\n    [blockOperation addExecutionBlock:^{\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@&quot;block operation 2, thread = %@&quot;, [NSThread currentThread]);\n    }];\n    \n    [blockOperation addExecutionBlock:^{\n        [NSThread sleepForTimeInterval:1.5];\n        NSLog(@&quot;block operation 3, thread = %@&quot;, [NSThread currentThread]);\n    }];\n    \n    [blockOperation setCompletionBlock:^{\n        NSLog(@&quot;end block operation, thread = %@&quot;, [NSThread currentThread]);\n    }];\n    \n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    \n    [queue addOperation:blockOperation];\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h5 id="操作依赖" tabindex="-1"><a class="header-anchor" href="#操作依赖" aria-hidden="true">#</a> 操作依赖</h5><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (IBAction)test_dependency:(id)sender {\n    \n    _queue = [[NSOperationQueue alloc] init];\n    \n    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{\n        [NSThread sleepForTimeInterval:3];\n        NSLog(@&quot;op1 , thread = %@&quot;, [NSThread currentThread]);\n    }];\n    \n    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{\n        [NSThread sleepForTimeInterval:2];\n        NSLog(@&quot;op2 , thread = %@&quot;, [NSThread currentThread]);\n    }];\n    \n    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{\n        [NSThread sleepForTimeInterval:0.5];\n        NSLog(@&quot;op3 , thread = %@&quot;, [NSThread currentThread]);\n    }];\n    \n    // op1 完成之后，开始op2 / op3 任务\n    [op2 addDependency:op1];\n    [op3 addDependency:op1];\n    \n    [_queue addOperation:op1];\n    [_queue addOperation:op2];\n    [_queue addOperation:op3];\n    \n    NSLog(@&quot;test dependency , thread = %@&quot;, [NSThread currentThread]);\n}\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h5 id="自定义nsoperation" tabindex="-1"><a class="header-anchor" href="#自定义nsoperation" aria-hidden="true">#</a> 自定义NSOperation</h5><blockquote><p>自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// 创建 CustomOperation 类， 继承自 NSOperation\n@interface CustomOperation : NSOperation\n@end\n\n@implementation CustomOperation\n\n- (void)main\n{\n    NSTimeInterval time = arc4random() % 6;\n    [NSThread sleepForTimeInterval:time];\n    NSLog(@&quot;thread %@&quot;, [NSThread currentThread]);\n}\n\n@end\n\n// ======= 在其他文件调用\n\n- (IBAction)test_custom_operation:(id)sender {\n    \n    CustomOperation *operation1 = [[CustomOperation alloc] init];\n    CustomOperation *operation2 = [[CustomOperation alloc] init];\n    \n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    \n    [queue addOperation:operation1];\n    [queue addOperation:operation2];\n}\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h5 id="队列其他方法" tabindex="-1"><a class="header-anchor" href="#队列其他方法" aria-hidden="true">#</a> 队列其他方法</h5><blockquote><p>maxConcurrentOperationCount 这是最大并发数</p></blockquote><blockquote><p>suspended 队列暂停/继续</p></blockquote><blockquote><p>cancelAllOperations 取消所有操作</p></blockquote><h4 id="常见面试题" tabindex="-1"><a class="header-anchor" href="#常见面试题" aria-hidden="true">#</a> 常见面试题</h4><p>下面代码会输出什么？ 为什么？</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (void)viewDidLoad {\n\t[super viewDidLoad];\n\tNSLog(@&quot;1&quot;);\n   \tdispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@&quot;2&quot;);\n    });\n    NSLog(@&quot;3&quot;);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h5 id="答案" tabindex="-1"><a class="header-anchor" href="#答案" aria-hidden="true">#</a> 答案</h5><p><strong>输出: 1</strong>， 然后崩溃</p><h5 id="原因" tabindex="-1"><a class="header-anchor" href="#原因" aria-hidden="true">#</a> 原因</h5><p>系统维护的<code>dispatch_get_main_queue()</code>这个队列里面在执行<code>viewDidLoad</code>方法，在<code>viewDidLoad</code>中又再次在<code>dispatch_get_main_queue()</code>这个相同的队列里面执行<code>block</code>方法。</p><p>由于串行队列<code>FIFO</code>原则，系统维护的<code>dispatch_get_main_queue()</code>先进栈，所以要先执行完毕后，再执行后进栈的队列任务，而系统维护的<code>dispatch_get_main_queue()</code>执行完的条件时<code>viewDidLoad</code>方法执行完毕，所以系统维护的<code>dispatch_get_main_queue()</code>会等待<code>dispatch_sync</code>调用的<code>dispatch_get_main_queue()</code>执行完毕，<code>dispatch_sync</code>调用的<code>dispatch_get_main_queue()</code>又在等待先进栈的系统维护的<code>dispatch_get_main_queue()</code>执行完毕，这样就陷入死循环.</p><p>下面代码崩溃原因同上：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);\ndispatch_async(queue, ^{\n    NSLog(@&quot;1&quot;);\n    dispatch_sync(queue, ^{\n        NSLog(@&quot;2&quot;);\n    });\n    NSLog(@&quot;3&quot;);\n});\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>输出1，然后崩溃</p><h5 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h5>',83),l={href:"https://www.jianshu.com/p/0b0d9b1f1f19",target:"_blank",rel:"noopener noreferrer"},p=(0,s.Uk)("关于iOS多线程，你看我就够了"),t={},i=(0,a(3744).Z)(t,[["render",function(n,e){const a=(0,s.up)("OutboundLink");return(0,s.wg)(),(0,s.iD)(s.HY,null,[r,(0,s._)("ol",null,[(0,s._)("li",null,[(0,s._)("a",l,[p,(0,s.Wm)(a)])])])],64)}]])},3744:(n,e)=>{e.Z=(n,e)=>{for(const[a,s]of e)n[a]=s;return n}}}]);