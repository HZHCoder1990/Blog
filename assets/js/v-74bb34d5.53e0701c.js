"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[191],{8425:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a={key:"v-74bb34d5",path:"/iOS/open-analysis/AFNetworking.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:3,title:"AFNetworking  源码分析",slug:"afnetworking-源码分析",children:[]}],filePathRelative:"iOS/open-analysis/AFNetworking.md",git:{updatedTime:1633945792e3,contributors:[{name:"peak",email:"peak@jiemogame.com",commits:2}]}}},1133:(e,n,s)=>{s.r(n),s.d(n,{default:()=>k});var a=s(6252);const r=(0,a.uE)('<h3 id="afnetworking-源码分析" tabindex="-1"><a class="header-anchor" href="#afnetworking-源码分析" aria-hidden="true">#</a> AFNetworking 源码分析</h3><p align="right">Update: 2019-5-11</p><p>SDK 版本 3.2.1</p><h4 id="目录" tabindex="-1"><a class="header-anchor" href="#目录" aria-hidden="true">#</a> 目录</h4><ul><li><a href="#architect-flow">架构图</a></li><li><a href="#request-flow">网络请求流程</a></li><li><a href="#response-flow">网络响应流程</a></li><li><a href="#cache">缓存</a></li><li><a href="#image-download">图片下载</a></li><li><a href="#others">其他知识</a></li><li><a href="#reference">参考</a></li></ul><h4 id="架构图" tabindex="-1"><a class="header-anchor" href="#架构图" aria-hidden="true">#</a> <a name="architect-flow"></a>架构图</h4><ul><li>网络通信 <ul><li><code>AFURLSessionManager</code> 基于 <code>NSURLSession</code> 做了一系列的封装，负责真正的网络请求。</li><li><code>AFHTTPSessionManager</code> 继承自 <code>AFURLSessionManager</code> ， 具体请求逻辑交给父类来完成，一般使用该类发起网络请求。</li></ul></li><li>网络状态监控 <ul><li><code>AFNetworkReachabilityManager</code> 负责监控网络状态。</li></ul></li><li>序列化/反序列化 <ul><li><code>AFURLRequestSerialization</code> 负责构造 <code>NSURLRequest</code> 。</li><li><code>AFURLResponseSerrialization</code> 负责解析 <code>NSURLResponse</code> 。</li></ul></li><li>安全策略 <ul><li><code>AFSecurityPolicy</code></li></ul></li><li>UIKit扩展 <ul><li><code>UIImageView+AFNetworking</code> <code>UIImageView</code> 的扩展，负责图片的下载以及缓存。</li><li><code>AFAutoPurgingImageCache</code> 负责图片缓存</li><li><code>AFImageDownloader</code> 负责图片下载，基于 <code>AFHTTPSessionManager</code> 的封装。</li></ul></li></ul><h4 id="网络请求流程" tabindex="-1"><a class="header-anchor" href="#网络请求流程" aria-hidden="true">#</a> <a name="request-flow"></a>网络请求流程</h4><p>以发起 <code>POST</code> 请求为例，</p><ol><li>调用如下接口初始化 <code>AFHTTPSessionManager</code> 对象</li></ol><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (instancetype)initWithBaseURL:(nullable NSURL *)url\n           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>初始化做了如下操作</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (instancetype)initWithBaseURL:(NSURL *)url\n           sessionConfiguration:(NSURLSessionConfiguration *)configuration\n{\n    // 调用父类接口，初始化父类\n    self = [super initWithSessionConfiguration:configuration];\n    if (!self) {\n        return nil;\n    }\n    \n    // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected\n    if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) {\n        url = [url URLByAppendingPathComponent:@&quot;&quot;];\n    }\n\n    self.baseURL = url;\n    \n    // 初始化 请求和响应 的序列化对象\n    self.requestSerializer = [AFHTTPRequestSerializer serializer];\n    self.responseSerializer = [AFJSONResponseSerializer serializer];\n\n    return self;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><ol start="2"><li>发起 <code>POST</code> 请求</li></ol><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString\n                    parameters:(nullable id)parameters\n                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success\n                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>该 <code>POST</code> 请求最终调用到:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString\n                             parameters:(nullable id)parameters\n                                headers:(nullable NSDictionary &lt;NSString *, NSString *&gt; *)headers\n                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress\n                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success\n                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure\n{\n    // 构造dataTask对象\n    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;POST&quot; URLString:URLString parameters:parameters headers:headers uploadProgress:uploadProgress downloadProgress:nil success:success failure:failure];\n    \n    // 执行请求\n    [dataTask resume];\n    \n    return dataTask;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>构造 <code>NSURLSessionDataTask</code> 对象做了如下操作</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method\n                                       URLString:(NSString *)URLString\n                                      parameters:(id)parameters\n                                         headers:(NSDictionary &lt;NSString *, NSString *&gt; *)headers\n                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress\n                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress\n                                         success:(void (^)(NSURLSessionDataTask *, id))success\n                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure\n{\n    // 使用序列化对象 构造 Requst 对象\n    NSError *serializationError = nil;\n    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];\n    // 添加请求头信息到Request对象中\n    for (NSString *headerField in headers.keyEnumerator) {\n        [request addValue:headers[headerField] forHTTPHeaderField:headerField];\n    }\n    if (serializationError) {\n        if (failure) {\n            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{\n                failure(nil, serializationError);\n            });\n        }\n\n        return nil;\n    }\n    \n    // 调用父类接口构造dataTask\n    __block NSURLSessionDataTask *dataTask = nil;\n    dataTask = [self dataTaskWithRequest:request\n                          uploadProgress:uploadProgress\n                        downloadProgress:downloadProgress\n                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {\n        if (error) {\n            if (failure) {\n                failure(dataTask, error);\n            }\n        } else {\n            if (success) {\n                success(dataTask, responseObject);\n            }\n        }\n    }];\n\n    // 返回 dataTask\n    return dataTask;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>父类的构造 <code>dataTask</code> 做了如下操作</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request\n                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock\n                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock\n                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler {\n\n    // 生成 NSURLSessionDataTask 对象\n    __block NSURLSessionDataTask *dataTask = nil;\n    url_session_manager_create_task_safely(^{\n        dataTask = [self.session dataTaskWithRequest:request];\n    });\n\n    // 添加代理\n    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];\n\n    return dataTask;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>添加代理主要作用是把该 <code>dataTask</code> 和它对应的回调信息保存起来</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask\n                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock\n              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock\n             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler\n{\n    // 生成dataTask代理对象\n    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];\n    delegate.manager = self;\n    // 保存请求的回调到dataTask的代理对象上\n    delegate.completionHandler = completionHandler;\n\n    // 把该dataTask代理对象保存起来\n    dataTask.taskDescription = self.taskDescriptionForSessionTasks;\n    [self setDelegate:delegate forTask:dataTask];\n\n    delegate.uploadProgressBlock = uploadProgressBlock;\n    delegate.downloadProgressBlock = downloadProgressBlock;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>实际存入是根据该 <code>dataTask</code> 的 <code>taskIdentifier</code> 属性值作为key值，保存在字典中</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate\n            forTask:(NSURLSessionTask *)task\n{\n    NSParameterAssert(task);\n    NSParameterAssert(delegate);\n\n    [self.lock lock];\n    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;\n    [self addNotificationObserverForTask:task];\n    [self.lock unlock];\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="网络响应流程" tabindex="-1"><a class="header-anchor" href="#网络响应流程" aria-hidden="true">#</a> <a name="response-flow"></a>网络响应流程</h4><p><code>AFURLSessionManager</code> 实现了 <code>NSURLSessionDelegate</code>, <code>NSURLSessionTaskDelegate</code>, <code>NSURLSessionDataDelegate</code>, <code>NSURLSessionDownloadDelegate</code> 等网络协议。</p><p>接受数据处理流程如下：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (void)URLSession:(NSURLSession *)session\n          dataTask:(NSURLSessionDataTask *)dataTask\n    didReceiveData:(NSData *)data\n{\n    // 获取task的代理对象，并由该代理对象去处理相关数据\n    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];\n    [delegate URLSession:session dataTask:dataTask didReceiveData:data];\n    \n    // block如果存在，执行block处理数据\n    if (self.dataTaskDidReceiveData) {\n        self.dataTaskDidReceiveData(session, dataTask, data);\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>获取 <code>task</code> 的代理对象</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task {\n    NSParameterAssert(task);\n\n    AFURLSessionManagerTaskDelegate *delegate = nil;\n    [self.lock lock]; // 加锁\n    // 根据每一个 task 的 taskIdentifier 的属性值来获取代理对象\n    delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];\n    [self.lock unlock];\n\n    return delegate;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><code>task</code> 的代理对象 <code>AFURLSessionManagerTaskDelegate</code> ，实现了 <code>NSURLSessionTaskDelegate</code>, <code>NSURLSessionDataDelegate</code>, <code>NSURLSessionDownloadDelegate</code> 协议。</p><p>接收的数据具体由 <code>AFURLSessionManagerTaskDelegate</code> 类来处理</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (void)URLSession:(__unused NSURLSession *)session\n          dataTask:(__unused NSURLSessionDataTask *)dataTask\n    didReceiveData:(NSData *)data\n{\n    // 更新下载进度\n    self.downloadProgress.totalUnitCount = dataTask.countOfBytesExpectedToReceive;\n    self.downloadProgress.completedUnitCount = dataTask.countOfBytesReceived;\n\t\t// 保存数据\n    [self.mutableData appendData:data];\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>下载完成处理流程：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (void)URLSession:(NSURLSession *)session\n              task:(NSURLSessionTask *)task\ndidCompleteWithError:(NSError *)error\n{\n    // 获取代理\n    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];\n\n    // delegate may be nil when completing a task in the background\n    if (delegate) {\n      \t// 代理来处理数据\n        [delegate URLSession:session task:task didCompleteWithError:error];\n        // 移除代理对象\n        [self removeDelegateForTask:task];\n    }\n\t\t// block 处理下载完成的情况\n    if (self.taskDidComplete) {\n        self.taskDidComplete(session, task, error);\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>代理具体处理数据为</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (void)URLSession:(__unused NSURLSession *)session\n              task:(NSURLSessionTask *)task\ndidCompleteWithError:(NSError *)error\n{\n    __strong AFURLSessionManager *manager = self.manager;\n\n    __block id responseObject = nil;\n\n    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];\n    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;\n    \n    // 提升性能，不再需要的数据，及时释放\n    //Performance Improvement from #2672\n    NSData *data = nil;\n    if (self.mutableData) {\n        data = [self.mutableData copy];\n        //We no longer need the reference, so nil it out to gain back some memory.\n        self.mutableData = nil;\n    }\n\n#if AF_CAN_USE_AT_AVAILABLE &amp;&amp; AF_CAN_INCLUDE_SESSION_TASK_METRICS\n    if (@available(iOS 10, macOS 10.12, watchOS 3, tvOS 10, *)) {\n        if (self.sessionTaskMetrics) {\n            userInfo[AFNetworkingTaskDidCompleteSessionTaskMetrics] = self.sessionTaskMetrics;\n        }\n    }\n#endif\n\n    if (self.downloadFileURL) {\n        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;\n    } else if (data) {\n        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;\n    }\n\n    if (error) {\n        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;\n\n        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{\n           // 执行代理对象的 completionHandler \n            if (self.completionHandler) {\n                self.completionHandler(task.response, responseObject, error);\n            }\n\t\t\t\t\t\t// 发送通知 下载完成\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];\n            });\n        });\n    } else {\n        dispatch_async(url_session_manager_processing_queue(), ^{\n          \t// 处理返回的数据\n          \t// 处理返回的错误码是否有效\n          \t// 转成json数据\n            NSError *serializationError = nil;\n            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];\n\n            if (self.downloadFileURL) {\n                responseObject = self.downloadFileURL;\n            }\n\n            if (responseObject) {\n                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;\n            }\n\n            if (serializationError) {\n                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;\n            }\n\n            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{\n              \t// 执行代理对象的 completionHandler \n                if (self.completionHandler) {\n                    self.completionHandler(task.response, responseObject, serializationError);\n                }\n \t\t\t\t\t\t\t\t// 发送通知 下载完成\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];\n                });\n            });\n        });\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br></div></div><h4 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> <a name="cache"></a>缓存</h4><p>UIKit 的扩展库中，下载图片的时候，使用了内存缓存类 <code>AFAutoPurgingImageCache</code>。该类实现了 <code>AFImageRequestCache</code> 内存缓存协议。</p><p>计算图片内存大小代码如下：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (instancetype)initWithImage:(UIImage *)image identifier:(NSString *)identifier {\n    if (self = [self init]) {\n        self.image = image;\n        self.identifier = identifier;\n\n        CGSize imageSize = CGSizeMake(image.size.width * image.scale, image.size.height * image.scale);\n        // 每个像素占4个字节， 32个bit\n        CGFloat bytesPerPixel = 4.0;\n        CGFloat bytesPerSize = imageSize.width * imageSize.height;\n        self.totalBytes = (UInt64)bytesPerPixel * (UInt64)bytesPerSize;\n        self.lastAccessDate = [NSDate date];\n    }\n    return self;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>缓存图片，实现了 <code>AFImageRequestCache</code> 协议的如下方法</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**\n Adds the image to the cache with the given identifier.\n\n @param image The image to cache.\n @param identifier The unique identifier for the image in the cache.\n */\n- (void)addImage:(UIImage *)image withIdentifier:(NSString *)identifier;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>具体实现如下：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (void)addImage:(UIImage *)image withIdentifier:(NSString *)identifier {\n  \t//  `dispatch_barrier_async` 保证并行队列 `self.synchronizationQueue` 里面的其他操作都完成之后，在执行添加缓存操作\n  \tdispatch_barrier_async(self.synchronizationQueue, ^{\n        AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];\n\t\t\t\t// 判断图片是否已经缓存过\n        AFCachedImage *previousCachedImage = self.cachedImages[identifier];\n        if (previousCachedImage != nil) {\n            self.currentMemoryUsage -= previousCachedImage.totalBytes;\n        }\n\n        self.cachedImages[identifier] = cacheImage;\n        self.currentMemoryUsage += cacheImage.totalBytes;\n    });\n\t\t\n  \t// 添加缓存之后，检查缓存是否已经超过设定的阈值\n    dispatch_barrier_async(self.synchronizationQueue, ^{\n        if (self.currentMemoryUsage &gt; self.memoryCapacity) {\n            UInt64 bytesToPurge = self.currentMemoryUsage - self.preferredMemoryUsageAfterPurge;\n            NSMutableArray &lt;AFCachedImage*&gt; *sortedImages = [NSMutableArray arrayWithArray:self.cachedImages.allValues];\n            NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@&quot;lastAccessDate&quot;\n                                                                           ascending:YES];\n          \t// 根据最后存取时间，来升序排序\n            [sortedImages sortUsingDescriptors:@[sortDescriptor]];\n\n            UInt64 bytesPurged = 0;\n\t\t\t\t\t\t// 移除时间最早的图片\n            for (AFCachedImage *cachedImage in sortedImages) {\n                [self.cachedImages removeObjectForKey:cachedImage.identifier];\n                bytesPurged += cachedImage.totalBytes;\n                if (bytesPurged &gt;= bytesToPurge) {\n                    break ;\n                }\n            }\n            self.currentMemoryUsage -= bytesPurged;\n        }\n    });\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div>',46),l=(0,a.Uk)("使用了 "),i=(0,a._)("code",null,"NSSortDescriptor",-1),p=(0,a.Uk)(" 来根据最后访问时间来排序， 具体用法参考作者博客 "),b={href:"https://nshipster.com/nssortdescriptor/",target:"_blank",rel:"noopener noreferrer"},c=(0,a.Uk)("NSSortDescriptor"),o=(0,a.Uk)("。"),t=(0,a.uE)('<p>移除图片具体实现如下:</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (BOOL)removeImageWithIdentifier:(NSString *)identifier {\n    __block BOOL removed = NO;\n  \t// 等待并行队列其他操作完成，同步执行移除操作\n    dispatch_barrier_sync(self.synchronizationQueue, ^{\n        AFCachedImage *cachedImage = self.cachedImages[identifier];\n        if (cachedImage != nil) {\n            [self.cachedImages removeObjectForKey:identifier];\n            self.currentMemoryUsage -= cachedImage.totalBytes;\n            removed = YES;\n        }\n    });\n    return removed;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="图片下载" tabindex="-1"><a class="header-anchor" href="#图片下载" aria-hidden="true">#</a> <a name="image-download"></a>图片下载</h4><p>以 <code>UIImageView+AFNetworking</code> 为例，提供了如下下载接口</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>// 根据 URL 下载图片\n- (void)setImageWithURL:(NSURL *)url;\n\n// 根据 URL 下载图片，并设置占位图\n- (void)setImageWithURL:(NSURL *)url placeholderImage:(nullable UIImage *)placeholderImage;\n\n// 根据请求下载图片，并设置占位图，提供回调\n- (void)setImageWithURLRequest:(NSURLRequest *)urlRequest \nplaceholderImage:(nullable UIImage *)placeholderImage \nsuccess:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *image))success \nfailure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>最终都方法都进入到</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (void)setImageWithURLRequest:(NSURLRequest *)urlRequest\n              placeholderImage:(UIImage *)placeholderImage\n                       success:(void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *image))success\n                       failure:(void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure\n{\n    // 检查 URL\n    if ([urlRequest URL] == nil) {\n        self.image = placeholderImage;\n        if (failure) {\n            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorBadURL userInfo:nil];\n            failure(urlRequest, nil, error);\n        }\n        return;\n    }\n    \n    // 该请求是否正在执行\n    if ([self isActiveTaskURLEqualToURLRequest:urlRequest]){\n        return;\n    }\n    \n   \t// 取消当前执行的下载任务                \n    [self cancelImageDownloadTask];\n    \n    // 优先从内存缓存中获取图片\n    AFImageDownloader *downloader = [[self class] sharedImageDownloader];\n    id &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache;\n\n    //Use the image from the image cache if it exists\n    UIImage *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:nil];\n    if (cachedImage) {\n        if (success) {\n            success(urlRequest, nil, cachedImage);\n        } else {\n            self.image = cachedImage;\n        }\n        // 获取到缓存，清除正在下载的操作\n        [self clearActiveDownloadInformation];\n    } else {\n        // 没有缓存， 先显示占位图(如果提供的话)\n        if (placeholderImage) {\n            self.image = placeholderImage;\n        }\n\t\t\t\t// 执行真正的下载操作\n        __weak __typeof(self)weakSelf = self;\n        NSUUID *downloadID = [NSUUID UUID];\n        AFImageDownloadReceipt *receipt;\n        receipt = [downloader\n                   downloadImageForURLRequest:urlRequest\n                   withReceiptID:downloadID\n                   success:^(NSURLRequest * _Nonnull request, NSHTTPURLResponse * _Nullable response, UIImage * _Nonnull responseObject) {\n                       __strong __typeof(weakSelf)strongSelf = weakSelf;\n                       if ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) {\n                           if (success) {\n                               success(request, response, responseObject);\n                           } else if(responseObject) {\n                               // 显示下载的图片\n                               strongSelf.image = responseObject;\n                           }\n                           [strongSelf clearActiveDownloadInformation];\n                       }\n\n                   }\n                   failure:^(NSURLRequest * _Nonnull request, NSHTTPURLResponse * _Nullable response, NSError * _Nonnull error) {\n                       __strong __typeof(weakSelf)strongSelf = weakSelf;\n                        if ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) {\n                            if (failure) {\n                                failure(request, response, error);\n                            }\n                            [strongSelf clearActiveDownloadInformation];\n                        }\n                   }];\n\n        self.af_activeImageDownloadReceipt = receipt;\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br></div></div><p>下载图片在 <code>AFImageDownloader</code> 中执行，该类是对 <code>AFHTTPSessionManager</code> 的网络请求做了封装，用于执行图片下载以及图片缓存等操作。 具体下载逻辑如下：</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (nullable AFImageDownloadReceipt *)downloadImageForURLRequest:(NSURLRequest *)request\n                                                  withReceiptID:(nonnull NSUUID *)receiptID\n                                                        success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse  * _Nullable response, UIImage *responseObject))success\n                                                        failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure {\n    __block NSURLSessionDataTask *task = nil;\n    // 在串行队列里面 同步 生成下载操作，保证线程安全\n    dispatch_sync(self.synchronizationQueue, ^{\n        \n        NSString *URLIdentifier = request.URL.absoluteString;\n        if (URLIdentifier == nil) {\n            if (failure) {\n                NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorBadURL userInfo:nil];\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    failure(request, nil, error);\n                });\n            }\n            return;\n        }\n\n        // 1) Append the success and failure blocks to a pre-existing request if it already exists\n        AFImageDownloaderMergedTask *existingMergedTask = self.mergedTasks[URLIdentifier];\n        if (existingMergedTask != nil) {\n            // 正在下载，添加下载下载回调\n            AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure];\n            [existingMergedTask addResponseHandler:handler];\n            task = existingMergedTask.task;\n            return;\n        }\n\n        // 2) Attempt to load the image from the image cache if the cache policy allows it\n        switch (request.cachePolicy) {\n            case NSURLRequestUseProtocolCachePolicy:\n            case NSURLRequestReturnCacheDataElseLoad:\n            case NSURLRequestReturnCacheDataDontLoad: {\n                // 获取缓存图片\n                UIImage *cachedImage = [self.imageCache imageforRequest:request withAdditionalIdentifier:nil];\n                if (cachedImage != nil) {\n                    if (success) {\n                        dispatch_async(dispatch_get_main_queue(), ^{\n                            success(request, nil, cachedImage);\n                        });\n                    }\n                    return;\n                }\n                break;\n            }\n            default:\n                break;\n        }\n\n        // 3) Create the request and set up authentication, validation and response serialization\n        NSUUID *mergedTaskIdentifier = [NSUUID UUID];\n        NSURLSessionDataTask *createdTask;\n        __weak __typeof__(self) weakSelf = self;\n        // 创造下载请求\n        createdTask = [self.sessionManager\n                       dataTaskWithRequest:request\n                       uploadProgress:nil\n                       downloadProgress:nil\n                       completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {\n                           dispatch_async(self.responseQueue, ^{\n                               __strong __typeof__(weakSelf) strongSelf = weakSelf;\n                               // 取出保存的下载请求\n                               AFImageDownloaderMergedTask *mergedTask = [strongSelf safelyGetMergedTask:URLIdentifier];\n                               if ([mergedTask.identifier isEqual:mergedTaskIdentifier]) {\n                                   mergedTask = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier];\n                                   if (error) {\n                                       // 回调所有的失败回调信息\n                                       for (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) {\n                                           if (handler.failureBlock) {\n                                               dispatch_async(dispatch_get_main_queue(), ^{\n                                                   handler.failureBlock(request, (NSHTTPURLResponse *)response, error);\n                                               });\n                                           }\n                                       }\n                                   } else {\n                                       // 缓存下载图片\n                                       if ([strongSelf.imageCache shouldCacheImage:responseObject forRequest:request withAdditionalIdentifier:nil]) {\n                                           [strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:nil];\n                                       }\n                                       // 回调所有的成功回调信息\n                                       for (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) {\n                                           if (handler.successBlock) {\n                                               dispatch_async(dispatch_get_main_queue(), ^{\n                                                   handler.successBlock(request, (NSHTTPURLResponse *)response, responseObject);\n                                               });\n                                           }\n                                       }\n                                       \n                                   }\n                               }\n                               [strongSelf safelyDecrementActiveTaskCount];\n                               // 开启一下一个请求\n                               [strongSelf safelyStartNextTaskIfNecessary];\n                           });\n                       }];\n        // 存储下载请求，用于下载完成时的回调\n        // 4) Store the response handler for use when the request completes\n        AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID\n                                                                                                   success:success\n                                                                                                   failure:failure];\n        AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc]\n                                                   initWithURLIdentifier:URLIdentifier\n                                                   identifier:mergedTaskIdentifier\n                                                   task:createdTask];\n        [mergedTask addResponseHandler:handler];\n        self.mergedTasks[URLIdentifier] = mergedTask;\n        // 判断下载请求是否达到阈值，默认最大下载4个\n        // 5) Either start the request or enqueue it depending on the current active request count\n        if ([self isActiveRequestCountBelowMaximumLimit]) {\n            [self startMergedTask:mergedTask];\n        } else {\n            [self enqueueMergedTask:mergedTask];\n        }\n\n        task = mergedTask.task;\n    });\n    if (task) {\n        return [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID task:task];\n    } else {\n        return nil;\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br></div></div><p>执行下载逻辑如下：</p><ol><li>判断 <code>URL</code> 是否合理</li><li>判断这个 <code>URL</code> 生成的 <code>task</code> 是否已经缓存， 如果已经缓存，给该 <code>task</code> 添加一个回调</li><li>根据请求策略去获取缓存图片</li><li>没有获取到缓存图片，则创建一个新的下载请求 task</li><li>缓存该下载 <code>task</code>，跟下载回调，下载 <code>URL</code> 等信息绑定在一起，方便下载成功之后，查找回调信息等</li><li>判断当前的活跃的请求个数是否已经超过阈值，如果没有执行下载操作，如果超过，根据请求缓存策略，把该 <code>task</code> 存到适当的位置</li><li>下载成功之后，根据 URL 取出保存的下载回调信息，根据下载结果执行相应的下载回调</li></ol><h4 id="其他知识" tabindex="-1"><a class="header-anchor" href="#其他知识" aria-hidden="true">#</a> <a name="others"></a>其他知识</h4><ol><li><p>保证线程安全</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>- (AFImageDownloaderMergedTask *)safelyGetMergedTask:(NSString *)URLIdentifier {\n    __block AFImageDownloaderMergedTask *mergedTask;\n    dispatch_sync(self.synchronizationQueue, ^(){\n        mergedTask = self.mergedTasks[URLIdentifier];\n    });\n    return mergedTask;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>取出下载任务的时候，在一个串行队列里面同步执行操作。</p></li><li><p>分类动态添加属性</p><div class="language-objective ext-objective line-numbers-mode"><pre class="language-objective"><code>+ (AFImageDownloader *)sharedImageDownloader {\n    return objc_getAssociatedObject(self, @selector(sharedImageDownloader)) ?: [AFImageDownloader defaultInstance];\n}\n\n+ (void)setSharedImageDownloader:(AFImageDownloader *)imageDownloader {\n    objc_setAssociatedObject(self, @selector(sharedImageDownloader), imageDownloader, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在 UIImageView 分类中动态添加下载对象。</p></li></ol><h4 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> <a name="reference"></a>参考</h4>',14),u={href:"http://cocoadocs.org/docsets/AFNetworking/3.1.0",target:"_blank",rel:"noopener noreferrer"},m=(0,a.Uk)("AFNetworking docs"),d={href:"https://www.jianshu.com/p/856f0e26279d",target:"_blank",rel:"noopener noreferrer"},g=(0,a.Uk)("AFNetworking 源码分析"),f={href:"https://juejin.im/post/5c5c2b8251882562826951b8",target:"_blank",rel:"noopener noreferrer"},S=(0,a.Uk)("浅谈移动端图片压缩"),h={},k=(0,s(3744).Z)(h,[["render",function(e,n){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[r,(0,a._)("p",null,[l,i,p,(0,a._)("a",b,[c,(0,a.Wm)(s)]),o]),t,(0,a._)("p",null,[(0,a._)("a",u,[m,(0,a.Wm)(s)])]),(0,a._)("p",null,[(0,a._)("a",d,[g,(0,a.Wm)(s)])]),(0,a._)("p",null,[(0,a._)("a",f,[S,(0,a.Wm)(s)])])],64)}]])},3744:(e,n)=>{n.Z=(e,n)=>{for(const[s,a]of n)e[s]=a;return e}}}]);